// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhoneNumberResponse {
    #[prost(string, repeated, tag = "1")]
    pub numbers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemovePhoneNumberRequest {
    #[prost(string, repeated, tag = "1")]
    pub phone_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemovePhoneNumberResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnreadMsgCountResponse {
    #[prost(int64, tag = "1")]
    pub count: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewTrustPhoneNumberRequest {
    #[prost(string, tag = "1")]
    pub phone_number: ::prost::alloc::string::String,
    /// 手机验证码
    #[prost(string, optional, tag = "3")]
    pub verify_code: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewTrustPhoneNumberResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchOsVersionRequest {
    #[prost(message, optional, tag = "1")]
    pub client_rule: ::core::option::Option<ClientVersionRule>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchOsVersionReply {
    /// 盒子系统的版本号
    #[prost(int32, tag = "1")]
    pub boxos_version: i32,
    #[prost(enumeration = "match_os_version_reply::Result", tag = "2")]
    pub match_result: i32,
    /// 如果Result不为OK,则期望的最小版本
    #[prost(int32, tag = "3")]
    pub wanted_min_version: i32,
}
/// Nested message and enum types in `MatchOSVersionReply`.
pub mod match_os_version_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        MatchOk = 0,
        /// 客户端版本过低
        ClientVersionTooLow = 1,
        /// 盒子系统版本过低
        BoxOsVersionTooLow = 2,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MatchOk => "MatchOK",
                Self::ClientVersionTooLow => "ClientVersionTooLow",
                Self::BoxOsVersionTooLow => "BoxOSVersionTooLow",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MatchOK" => Some(Self::MatchOk),
                "ClientVersionTooLow" => Some(Self::ClientVersionTooLow),
                "BoxOSVersionTooLow" => Some(Self::BoxOsVersionTooLow),
                _ => None,
            }
        }
    }
}
/// 内嵌到客户端
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientVersionRule {
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    /// 客户端的大版本号
    #[prost(int32, tag = "2")]
    pub client_version: i32,
    /// 支持的最低盒子系统版本
    #[prost(int32, tag = "3")]
    pub boxos_min_version: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxSystemStatus {
    #[prost(enumeration = "box_system_status::SysStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub service_url: ::prost::alloc::string::String,
    #[prost(enumeration = "box_system_status::ExceptionReason", optional, tag = "3")]
    pub exception_reason: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BoxSystemStatus`.
pub mod box_system_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SysStatus {
        /// 系统正在启动中
        Booting = 0,
        /// 处于正常可用状态
        Normal = 1,
        /// 处于异常状态，具体原因可读取ExceptionReason
        Exception = 2,
        /// 微服升级中，数秒后会自动重启，在该状态下，用户不应该使用盒子，以免导致数据丢失
        Upgrading2 = 3,
        /// 保留
        Reserved = 4,
    }
    impl SysStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Booting => "Booting",
                Self::Normal => "Normal",
                Self::Exception => "Exception",
                Self::Upgrading2 => "Upgrading2",
                Self::Reserved => "Reserved",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Booting" => Some(Self::Booting),
                "Normal" => Some(Self::Normal),
                "Exception" => Some(Self::Exception),
                "Upgrading2" => Some(Self::Upgrading2),
                "Reserved" => Some(Self::Reserved),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExceptionReason {
        /// 其他原因
        Unknown = 0,
        /// 等待加密数据盘被解密
        WaitDataDiskDecryption = 1,
        /// 数据盘没有初始化
        DataNotInit = 2,
        ///
        /// 1. 数据盘不存在（数据盘未插，或内部的 box.data.path 配置不正确）
        /// 2. 数据盘里已有分区（非 btrfs）
        /// 3. 数据盘无法挂载（文件系统损坏等）
        /// 4. 其它未意料的数据盘相关异常
        DataException = 3,
        /// 微服升级中，数秒后会自动重启，在该状态下，用户不应该使用盒子，以免导致数据丢失
        /// deprecated 请使用SysStatus的Upgrading2
        Upgrading = 4,
    }
    impl ExceptionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::WaitDataDiskDecryption => "WaitDataDiskDecryption",
                Self::DataNotInit => "DataNotInit",
                Self::DataException => "DataException",
                Self::Upgrading => "Upgrading",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "WaitDataDiskDecryption" => Some(Self::WaitDataDiskDecryption),
                "DataNotInit" => Some(Self::DataNotInit),
                "DataException" => Some(Self::DataException),
                "Upgrading" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod basic_bridge_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BasicBridgeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BasicBridgeClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BasicBridgeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BasicBridgeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BasicBridgeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 新增受信任电话号码
        /// 如果没有传递验证码那么会发送验证码
        /// 如果传递了验证码会验证验证码
        pub async fn new_trust_phone_number(
            &mut self,
            request: impl tonic::IntoRequest<super::NewTrustPhoneNumberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NewTrustPhoneNumberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/NewTrustPhoneNumber",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.BasicBridge",
                        "NewTrustPhoneNumber",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出用户所有手机号
        pub async fn list_phone_number(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListPhoneNumberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/ListPhoneNumber",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.BasicBridge",
                        "ListPhoneNumber",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 移除手机号
        pub async fn remove_phone_number(
            &mut self,
            request: impl tonic::IntoRequest<super::RemovePhoneNumberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemovePhoneNumberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/RemovePhoneNumber",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.BasicBridge",
                        "RemovePhoneNumber",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 未读消息数量
        pub async fn unread_msg_count(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::UnreadMsgCountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/UnreadMsgCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.bridge.BasicBridge", "UnreadMsgCount"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 查询客户端与盒子系统的版本是否匹配
        pub async fn match_os_version(
            &mut self,
            request: impl tonic::IntoRequest<super::MatchOsVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MatchOsVersionReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/MatchOSVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.bridge.BasicBridge", "MatchOSVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 单向流的方式获取微服状态
        pub async fn latest_sys_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BoxSystemStatus>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.BasicBridge/LatestSysStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.BasicBridge",
                        "LatestSysStatus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustDeviceRequest {
    #[prost(string, tag = "2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// 指定的预备手机号
    #[prost(string, tag = "4")]
    pub phone_number: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub verification_code: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrustDeviceResponse {
    #[prost(enumeration = "trust_device_response::TrustDeviceStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TrustDeviceResponse`.
pub mod trust_device_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrustDeviceStatus {
        /// 手机号不合法
        PhonenumberInvalid = 0,
        /// 等待验证码
        WaitVerifycode = 1,
        /// 已添加至受信任设备
        DeviceTrusted = 2,
        /// 密码有误,用户信息有误
        UserinfoInvalid = 3,
        /// 操作失败
        OperationFailed = 4,
    }
    impl TrustDeviceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PhonenumberInvalid => "PHONENUMBER_INVALID",
                Self::WaitVerifycode => "WAIT_VERIFYCODE",
                Self::DeviceTrusted => "DEVICE_TRUSTED",
                Self::UserinfoInvalid => "USERINFO_INVALID",
                Self::OperationFailed => "OPERATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PHONENUMBER_INVALID" => Some(Self::PhonenumberInvalid),
                "WAIT_VERIFYCODE" => Some(Self::WaitVerifycode),
                "DEVICE_TRUSTED" => Some(Self::DeviceTrusted),
                "USERINFO_INVALID" => Some(Self::UserinfoInvalid),
                "OPERATION_FAILED" => Some(Self::OperationFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgetPasswordRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
    /// 新密码
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgetPasswdResponse {
    #[prost(enumeration = "forget_passwd_response::ForgetPasswdStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ForgetPasswdResponse`.
pub mod forget_passwd_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForgetPasswdStatus {
        /// 成功
        Success = 0,
        /// Token无效
        TokenInvalid = 1,
        /// 没有此用户
        UserNotFound = 2,
        /// 操作失败
        OperationFailed = 3,
        /// 等待按钮点击
        PendingButtonClick = 4,
        /// 等待按按钮超时
        WaitButtonTimeout = 5,
    }
    impl ForgetPasswdStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::TokenInvalid => "TOKEN_INVALID",
                Self::UserNotFound => "USER_NOT_FOUND",
                Self::OperationFailed => "OPERATION_FAILED",
                Self::PendingButtonClick => "PENDING_BUTTON_CLICK",
                Self::WaitButtonTimeout => "WAIT_BUTTON_TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "TOKEN_INVALID" => Some(Self::TokenInvalid),
                "USER_NOT_FOUND" => Some(Self::UserNotFound),
                "OPERATION_FAILED" => Some(Self::OperationFailed),
                "PENDING_BUTTON_CLICK" => Some(Self::PendingButtonClick),
                "WAIT_BUTTON_TIMEOUT" => Some(Self::WaitButtonTimeout),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewForgetPasswdTokenRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub security_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub phone_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub verify_code: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewForgetPasswdTokenResponse {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinWithInviteCodeRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinWithInviteCodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyInviteCodeRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyInviteCodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NoTrustDeviceAdminRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub passwd: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NoTrustDeviceAdminReply {
    #[prost(enumeration = "no_trust_device_admin_reply::Status", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NoTrustDeviceAdminReply`.
pub mod no_trust_device_admin_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Success = 0,
        PendingButtonClick = 1,
        WaitButtonTimeout = 2,
        AuthFailed = 3,
        OperationFailed = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::PendingButtonClick => "PENDING_BUTTON_CLICK",
                Self::WaitButtonTimeout => "WAIT_BUTTON_TIMEOUT",
                Self::AuthFailed => "AUTH_FAILED",
                Self::OperationFailed => "OPERATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "PENDING_BUTTON_CLICK" => Some(Self::PendingButtonClick),
                "WAIT_BUTTON_TIMEOUT" => Some(Self::WaitButtonTimeout),
                "AUTH_FAILED" => Some(Self::AuthFailed),
                "OPERATION_FAILED" => Some(Self::OperationFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NoTrustDeviceUserRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub passwd: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewForgetPasswdTokenAdminRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewForgetPasswdTokenAdminRely {
    #[prost(string, optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "new_forget_passwd_token_admin_rely::Status", tag = "2")]
    pub status: i32,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NewForgetPasswdTokenAdminRely`.
pub mod new_forget_passwd_token_admin_rely {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Success = 0,
        PendingButtonClick = 1,
        WaitButtonTimeout = 2,
        OperationFailed = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::PendingButtonClick => "PENDING_BUTTON_CLICK",
                Self::WaitButtonTimeout => "WAIT_BUTTON_TIMEOUT",
                Self::OperationFailed => "OPERATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "PENDING_BUTTON_CLICK" => Some(Self::PendingButtonClick),
                "WAIT_BUTTON_TIMEOUT" => Some(Self::WaitButtonTimeout),
                "OPERATION_FAILED" => Some(Self::OperationFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUserRoleRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub passwd: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryUserRoleResponse {
    #[prost(enumeration = "query_user_role_response::Role", tag = "1")]
    pub role: i32,
}
/// Nested message and enum types in `QueryUserRoleResponse`.
pub mod query_user_role_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        User = 0,
        Admin = 1,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::User => "USER",
                Self::Admin => "ADMIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USER" => Some(Self::User),
                "ADMIN" => Some(Self::Admin),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod unsafe_bridge_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UnsafeBridgeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UnsafeBridgeClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UnsafeBridgeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UnsafeBridgeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UnsafeBridgeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 使用手机验证码的方式增加授信设备
        /// 不传递VerifyCode时发送验证码
        /// 传递了就会验证手机号和验证码并添加到受信任设备
        pub async fn trust_device(
            &mut self,
            request: impl tonic::IntoRequest<super::TrustDeviceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TrustDeviceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/TrustDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.bridge.UnsafeBridge", "TrustDevice"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// *
        /// 使用token找回密码
        ///
        /// 普通用户使用unsafe的NewForgetPasswordToken生成token
        /// 管理员用户使用admin的NewForgetPasswordTokenAdmin生成token
        pub async fn forget_password(
            &mut self,
            request: impl tonic::IntoRequest<super::ForgetPasswordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForgetPasswdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/ForgetPassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "ForgetPassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// *
        /// 获取用于找回密码的token
        /// 普通用户可基于管理员生成的安全码或受信任手机号找回
        /// 管理员用户可使用受信任手机号找回
        ///
        /// 传递手机号但是短信验证码未传递时 => 发送短信验证码
        /// 传递手机号也传递短信验证码时 => 验证并返回找回密码的token
        /// 传递了安全码时 => 验证并返回找回密码的token
        pub async fn new_forget_password_token(
            &mut self,
            request: impl tonic::IntoRequest<super::NewForgetPasswdTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NewForgetPasswdTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/NewForgetPasswordToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "NewForgetPasswordToken",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 生成用于忘记密码的token，管理员版本(通过功能按钮找回)
        pub async fn new_forget_passwd_token_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::NewForgetPasswdTokenAdminRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::NewForgetPasswdTokenAdminRely>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/NewForgetPasswdTokenAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "NewForgetPasswdTokenAdmin",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 使用邀请二维码创建用户
        /// token有效期为30分钟
        /// 用户名格式: 1-32位小写英文字母或数字
        /// 密码格式: 1-32位大小写英文字母或数字
        pub async fn join_with_invite_code(
            &mut self,
            request: impl tonic::IntoRequest<super::JoinWithInviteCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::JoinWithInviteCodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/JoinWithInviteCode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "JoinWithInviteCode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 验证邀请码是否可用
        pub async fn verify_invite_code(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyInviteCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyInviteCodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/VerifyInviteCode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "VerifyInviteCode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 没有受信任设备管理员处理方式
        /// 按按钮后把发起请求的peer client，加入到受信任列表中
        pub async fn no_trust_device_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::NoTrustDeviceAdminRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NoTrustDeviceAdminReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/NoTrustDeviceAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "NoTrustDeviceAdmin",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 没有受信任设备普通用户处理方式
        /// 给管理员的消息列表中发送一条消息请求，管理员点击允许同意后才行
        /// TODO: 最终版本应该是发送给管理员受信任设备验证码列表，界面在客户端内部
        pub async fn no_trust_device_user(
            &mut self,
            request: impl tonic::IntoRequest<super::NoTrustDeviceUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/NoTrustDeviceUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.bridge.UnsafeBridge",
                        "NoTrustDeviceUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TODO: 不应该接收用户密码，要利用DialerRole的规则
        /// RequireDialerRole hserver.DialerRole_NORMAL_USER
        /// RequireTrustDev false
        /// 查询用户是否是管理员
        pub async fn query_user_role(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryUserRoleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryUserRoleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.bridge.UnsafeBridge/QueryUserRole",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.bridge.UnsafeBridge", "QueryUserRole"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
