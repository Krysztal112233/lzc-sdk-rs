// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonLedSessionInfo {
    /// 事务描述，仅用于调试
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// 事务是否可以被抢占
    #[prost(bool, tag = "2")]
    pub preemptable: bool,
    /// 是否需要使用功能按钮（若不使用功能按钮，请不要设置以便节约资源)
    #[prost(bool, tag = "3")]
    pub use_button: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LedStream {
    /// LED 闪烁的亮暗比例（100%/65536）
    ///   0 表示一直暗，63356 表示一直亮
    #[prost(int32, tag = "1")]
    pub duty_cycle: i32,
    /// LED 闪烁周期（完成一次闪烁的时间，单位：毫秒。设置状态后，按钮会根据所设置的比例先亮后灭）
    #[prost(int32, tag = "2")]
    pub period: i32,
    /// 事务信息（必须在所有 LED 状态请求之前指定）
    #[prost(message, optional, tag = "3")]
    pub session: ::core::option::Option<ButtonLedSessionInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ButtonStream {
    /// 按钮事件
    #[prost(enumeration = "button_stream::ButtonEvent", tag = "1")]
    pub event: i32,
}
/// Nested message and enum types in `ButtonStream`.
pub mod button_stream {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ButtonEvent {
        /// 按钮被按下
        ButtonDown = 0,
        /// 按钮被松开
        ButtonUp = 1,
        /// 按钮被点击（按下后被快速松开，两次点击间隔不超过 500 毫秒）
        /// 当按钮被点击时，会先产生 BUTTON_DOWN 事件，然后产生 BUTTON_UP 事件，最后产生 BUTTON_CLICK 事件
        /// 如果只需要监听按钮被点击事件，可以忽略 BUTTON_DOWN 和 BUTTON_UP 事件
        /// 如果需要判断按钮是单击还是双击，需要自行等待 500 毫秒，如果没有收到 BUTTON_DOUBLE_CLICK 事件，则表示是单击
        ButtonClick = 2,
        /// 按钮被双击（两次点击间隔不超过 500 毫秒）
        /// 当按钮被双击时，会产生两次 BUTTON_CLICK 事件后才产生 BUTTON_DOUBLE_CLICK 事件
        /// 如果只需要监听按钮被双击事件，可以忽略 BUTTON_CLICK、BUTTON_DOWN、BUTTON_UP 事件
        ButtonDoubleClick = 3,
        /// 按钮被长按（按下时间超过 2 秒还未松开）
        /// 按钮被长按的事件过程：会先产生 BUTTON_DOWN 事件，然后产生 BUTTON_LONG_PRESS 事件，等到按钮被松开时，会产生 BUTTON_UP 事件
        ButtonLongPress = 4,
        /// 按钮被长按（按下时间超过 10 秒还未松开）
        /// 按钮被长按超过10秒的事件过程，会先产生 BUTTON_DOWN 事件，然后2秒后产生 BUTTON_LONG_PRESS 事件，然后8秒后产生 BUTTON_LONG_PRESS_10S 事件，等到按钮被松开时，会产生 BUTTON_UP 事件
        ButtonLongPress10s = 5,
    }
    impl ButtonEvent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ButtonDown => "BUTTON_DOWN",
                Self::ButtonUp => "BUTTON_UP",
                Self::ButtonClick => "BUTTON_CLICK",
                Self::ButtonDoubleClick => "BUTTON_DOUBLE_CLICK",
                Self::ButtonLongPress => "BUTTON_LONG_PRESS",
                Self::ButtonLongPress10s => "BUTTON_LONG_PRESS_10S",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUTTON_DOWN" => Some(Self::ButtonDown),
                "BUTTON_UP" => Some(Self::ButtonUp),
                "BUTTON_CLICK" => Some(Self::ButtonClick),
                "BUTTON_DOUBLE_CLICK" => Some(Self::ButtonDoubleClick),
                "BUTTON_LONG_PRESS" => Some(Self::ButtonLongPress),
                "BUTTON_LONG_PRESS_10S" => Some(Self::ButtonLongPress10s),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod button_led_session_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// kk - deprecated
    #[derive(Debug, Clone)]
    pub struct ButtonLedSessionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ButtonLedSessionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ButtonLedSessionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ButtonLedSessionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ButtonLedSessionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 抢占一个按钮 LED 事务。
        ///    连接失败说明事务已经其它组件占用并且不可抢占
        ///    如果连接成功后来被异常断开，大概率说明事务被其它组件抢占（所以如果有必要，需要设置 Preemptable = false 来实现该事务不可抢占）
        /// 由 `connect` 更改而来，避免冲突 
        pub async fn connect_led(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::LedStream>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ButtonStream>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.ButtonLedSessionService/Connect",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.ButtonLedSessionService",
                        "Connect",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsSubvolCreateRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsSubvolInfoRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsSubvolInfoResponse {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub gen: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsSubvolFindNewRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub gen: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsSubvolFindNewResponse {
    #[prost(string, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "2")]
    pub gen: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BtrfsRenameRequest {
    #[prost(string, tag = "1")]
    pub src_path: ::prost::alloc::string::String,
    /// src and dest path must reside in same subvolume
    /// otherwise rename/reflink will fail
    #[prost(string, tag = "2")]
    pub dest_path: ::prost::alloc::string::String,
    /// reflink instead of rename
    #[prost(bool, tag = "3")]
    pub reflink: bool,
}
/// Generated client implementations.
pub mod btrfs_util_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BtrfsUtilClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BtrfsUtilClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BtrfsUtilClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BtrfsUtilClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BtrfsUtilClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn subvol_create(
            &mut self,
            request: impl tonic::IntoRequest<super::BtrfsSubvolCreateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.BtrfsUtil/SubvolCreate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.BtrfsUtil", "SubvolCreate"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn subvol_info(
            &mut self,
            request: impl tonic::IntoRequest<super::BtrfsSubvolInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BtrfsSubvolInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.BtrfsUtil/SubvolInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.BtrfsUtil", "SubvolInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn subvol_find_new(
            &mut self,
            request: impl tonic::IntoRequest<super::BtrfsSubvolFindNewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BtrfsSubvolFindNewResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.BtrfsUtil/SubvolFindNew",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.BtrfsUtil", "SubvolFindNew"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn rename(
            &mut self,
            request: impl tonic::IntoRequest<super::BtrfsRenameRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.BtrfsUtil/Rename",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.BtrfsUtil", "Rename"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeveloperOptions {
    /// 禁用自动休眠长时间未使用的应用
    #[prost(bool, tag = "1")]
    pub disable_hibernation: bool,
    /// 开启 debug bridge
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub debug_bridge: bool,
    /// 开启 sshd 服务
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub debug_sshd: bool,
    /// 开启 open telemetry
    #[deprecated]
    #[prost(bool, tag = "4")]
    pub open_telemetry: bool,
    /// 禁用 upnp
    #[prost(bool, tag = "5")]
    pub disable_u_pn_p: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshdEnableRequest {
    /// 是否开启 sshd 服务
    #[prost(bool, tag = "1")]
    pub enable: bool,
    /// root 密码（该字段仅当 Enable 为 true 时有效）
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableSshdResponse {
    /// 是否开启了 sshd 服务
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Generated client implementations.
pub mod dev_opt_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DevOptServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DevOptServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DevOptServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DevOptServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DevOptServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_developer_options(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DeveloperOptions>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.DevOptService/GetDeveloperOptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.DevOptService",
                        "GetDeveloperOptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_developer_options(
            &mut self,
            request: impl tonic::IntoRequest<super::DeveloperOptions>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.DevOptService/SetDeveloperOptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.DevOptService",
                        "SetDeveloperOptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn sshd_enable(
            &mut self,
            request: impl tonic::IntoRequest<super::SshdEnableRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.DevOptService/SshdEnable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.DevOptService", "SshdEnable"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn sshd_enabled(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EnableSshdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.DevOptService/SshdEnabled",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.DevOptService",
                        "SshdEnabled",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirMonitorFindNewRequest {
    /// 要查询的目标路径，必须在用户 home 下
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// 上次调用返回的 token，首次调用传空即可
    #[prost(bytes = "vec", tag = "2")]
    pub token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirMonitorFindNewResponse {
    /// 自从上次调用，指定目录下新增的文件
    /// 若传入 token 无效，则为所有文件
    #[prost(string, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 返回的 token 仅对请求时传入的路径有效
    #[prost(bytes = "vec", tag = "2")]
    pub token: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod dir_monitor_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DirMonitorClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DirMonitorClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DirMonitorClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DirMonitorClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DirMonitorClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn find_new(
            &mut self,
            request: impl tonic::IntoRequest<super::DirMonitorFindNewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DirMonitorFindNewResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.DirMonitor/FindNew",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.DirMonitor", "FindNew"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// 发送者的appid, 由EventService填充
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// 接受者的appid
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub payload: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendRequest {
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub payload: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod event_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct EventServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EventServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EventServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EventServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EventServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 正常的事件订阅发送接口
        pub async fn subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Event>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.EventService/Subscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.EventService", "Subscribe"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn send(
            &mut self,
            request: impl tonic::IntoRequest<super::SendRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.EventService/Send",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.EventService", "Send"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PLedState {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SLedState {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonEventQueue {
    #[prost(message, repeated, tag = "1")]
    pub queue: ::prost::alloc::vec::Vec<button_event_queue::ButtonEvent>,
}
/// Nested message and enum types in `ButtonEventQueue`.
pub mod button_event_queue {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ButtonEvent {
        #[prost(enumeration = "ButtonEventKind", tag = "1")]
        pub kind: i32,
        #[prost(message, optional, tag = "2")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ButtonEventKind {
        /// 按钮被按下
        ButtonDown = 0,
        /// 按钮被松开
        ButtonUp = 1,
        /// 按钮被点击（按下后被快速松开，两次点击间隔不超过 500 毫秒）
        /// 当按钮被点击时，会先产生 BUTTON_DOWN 事件，然后产生 BUTTON_UP 事件，最后产生 BUTTON_CLICK 事件
        /// 如果只需要监听按钮被点击事件，可以忽略 BUTTON_DOWN 和 BUTTON_UP 事件
        /// 如果需要判断按钮是单击还是双击，需要自行等待 500 毫秒，如果没有收到 BUTTON_DOUBLE_CLICK 事件，则表示是单击
        ButtonClick = 2,
        /// 按钮被双击（两次点击间隔不超过 500 毫秒）
        /// 当按钮被双击时，会产生两次 BUTTON_CLICK 事件后才产生 BUTTON_DOUBLE_CLICK 事件
        /// 如果只需要监听按钮被双击事件，可以忽略 BUTTON_CLICK、BUTTON_DOWN、BUTTON_UP 事件
        ButtonDoubleClick = 3,
        /// 按钮被长按（按下时间超过 2 秒还未松开）
        /// 按钮被长按的事件过程：会先产生 BUTTON_DOWN 事件，然后产生 BUTTON_LONG_PRESS 事件，等到按钮被松开时，会产生 BUTTON_UP 事件
        ButtonLongPress = 4,
        /// 按钮被长按（按下时间超过 10 秒还未松开）
        /// 按钮被长按超过10秒的事件过程，会先产生 BUTTON_DOWN 事件，然后2秒后产生 BUTTON_LONG_PRESS 事件，然后8秒后产生 BUTTON_LONG_PRESS_10S 事件，等到按钮被松开时，会产生 BUTTON_UP 事件
        ButtonLongPress10s = 5,
    }
    impl ButtonEventKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ButtonDown => "BUTTON_DOWN",
                Self::ButtonUp => "BUTTON_UP",
                Self::ButtonClick => "BUTTON_CLICK",
                Self::ButtonDoubleClick => "BUTTON_DOUBLE_CLICK",
                Self::ButtonLongPress => "BUTTON_LONG_PRESS",
                Self::ButtonLongPress10s => "BUTTON_LONG_PRESS_10S",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUTTON_DOWN" => Some(Self::ButtonDown),
                "BUTTON_UP" => Some(Self::ButtonUp),
                "BUTTON_CLICK" => Some(Self::ButtonClick),
                "BUTTON_DOUBLE_CLICK" => Some(Self::ButtonDoubleClick),
                "BUTTON_LONG_PRESS" => Some(Self::ButtonLongPress),
                "BUTTON_LONG_PRESS_10S" => Some(Self::ButtonLongPress10s),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FanRpm {
    #[prost(int64, tag = "1")]
    pub rpm: i64,
}
/// Generated client implementations.
pub mod hal_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct HalServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HalServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HalServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HalServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HalServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Set 电源 LED (在 前面板上的 大个的 一条的 白色的)
        pub async fn set_p_led(
            &mut self,
            request: impl tonic::IntoRequest<super::PLedState>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.HalService/SetPLed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.HalService", "SetPLed"));
            self.inner.unary(req, path, codec).await
        }
        /// Get 电源 LED (在 前面板上的 大个的 一条的 白色的)
        pub async fn get_p_led(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::PLedState>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.HalService/GetPLed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.HalService", "GetPLed"));
            self.inner.unary(req, path, codec).await
        }
        /// Set 状态 LED (在 IO 面板上的 电源按钮边上的 小个的 红色的)
        pub async fn set_s_led(
            &mut self,
            request: impl tonic::IntoRequest<super::SLedState>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.HalService/SetSLed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.HalService", "SetSLed"));
            self.inner.unary(req, path, codec).await
        }
        /// 最近 30s 内 Button 事件队列。同时 续命 Button 监测 到 当前时间 +5s
        pub async fn get_button_event_queue(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ButtonEventQueue>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.HalService/GetButtonEventQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.HalService",
                        "GetButtonEventQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 风扇转速
        pub async fn get_fan_rpm(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::FanRpm>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.HalService/GetFanRpm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.HalService", "GetFanRpm"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PkgUrl {
    /// 内部地址
    ///      <http://pkgm.api-server.lzcapp/tmp/xxxx-0.2.1.lpk>
    /// 或外网地址
    ///      <https://repo.lazycat.cloud/a/c/accc-0.2.1.lpk>
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// pkg对应的sha256值，若不为空，
    /// 1. 本地有对应包的缓存，则会直接使用缓存
    /// 2. 本地若没有缓存，则会从 url 下载包，并校验包的 sha256 值
    #[prost(string, tag = "2")]
    pub sha256: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallRequest {
    /// 内部地址
    ///      <http://pkgm.api-server.lzcapp/tmp/xxxx-0.2.1.lpk>
    /// 或外网地址
    ///      <https://repo.lazycat.cloud/a/c/accc-0.2.1.lpk>
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// pkg对应的sha256值，若不为空，
    /// 1. 本地有对应包的缓存，则会直接使用缓存
    /// 2. 本地若没有缓存，则会从 url 下载包，并校验包的 sha256 值
    #[prost(string, tag = "3")]
    pub sha256: ::prost::alloc::string::String,
    /// 应用的 appid，若不指定则无下载中的状态
    #[prost(string, optional, tag = "1")]
    pub appid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub subdomain: ::core::option::Option<::prost::alloc::string::String>,
    /// 反正就是标题，一般是用来暂存，可能可以填入任何东西，不一定和应用标题相等
    #[prost(string, optional, tag = "5")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UninstallRequest {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    /// 卸载后是否清空 data 目录 (/lzcapp/var)
    #[prost(bool, tag = "2")]
    pub clear_data: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppDownloadProgress {
    /// 当前下载了的字节
    #[prost(uint64, tag = "1")]
    pub current: u64,
    /// LPK文件大小总字节
    #[prost(uint64, tag = "2")]
    pub total: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppInfo {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    /// 应用当前的安装状态
    #[prost(enumeration = "AppStatus", tag = "2")]
    pub status: i32,
    /// 应用当前的运行状态
    #[prost(enumeration = "InstanceStatus", tag = "12")]
    pub instance_status: i32,
    #[prost(string, optional, tag = "3")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// 应用图标所在的 url，如 <https://$boxdomain/sys/icons/$appid.png>
    /// 若应用无图标，则为空
    #[prost(string, optional, tag = "6")]
    pub icon: ::core::option::Option<::prost::alloc::string::String>,
    /// 应用所在的域名，如 app.box.heiyu.space
    #[prost(string, optional, tag = "7")]
    pub domain: ::core::option::Option<::prost::alloc::string::String>,
    /// 应用下载的进度（如果不是正在下载应用，则为空）
    #[prost(message, optional, tag = "8")]
    pub download_progress: ::core::option::Option<AppDownloadProgress>,
    /// 应用是否是预装应用（预装应用不可卸载）
    #[prost(bool, optional, tag = "9")]
    pub builtin: ::core::option::Option<bool>,
    /// 如果应用状态为安装失败，失败的原因（如果状态不是失败则为空）
    #[prost(string, optional, tag = "10")]
    pub error_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub unsupported_platforms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "13")]
    pub multi_instance: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppCfg {
    #[prost(bool, tag = "1")]
    pub background_task: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAppCfgRequest {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAppCfgResponse {
    #[prost(message, optional, tag = "1")]
    pub cfg: ::core::option::Option<AppCfg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAppCfgRequest {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cfg: ::core::option::Option<AppCfg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryApplicationRequest {
    /// 需要查询的 AppId 的列表，如果列表为空，则查询所有的应用
    #[prost(string, repeated, tag = "1")]
    pub appid_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryApplicationResponse {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<AppInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAppStorageUsageRequest {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub need_pkg: bool,
    #[prost(bool, tag = "3")]
    pub need_data: bool,
    #[prost(bool, tag = "4")]
    pub need_cache: bool,
    #[prost(bool, tag = "5")]
    pub need_tmp: bool,
    #[prost(bool, tag = "6")]
    pub need_userdata: bool,
    #[prost(bool, tag = "7")]
    pub need_image: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppStorageUsage {
    /// 应用本身占用的大小 (/lzcapp/pkg)
    #[prost(uint64, tag = "1")]
    pub pkg: u64,
    /// 应用数据的大小 (所有用户产生的应用数据大小) (/lzcapp/var)
    #[prost(uint64, tag = "2")]
    pub data: u64,
    /// 应用缓存的大小 (/lzcapp/cache)
    #[prost(uint64, tag = "3")]
    pub cache: u64,
    /// 应用临时文件的大小 (/tmp)
    #[prost(uint64, tag = "4")]
    pub tmp: u64,
    /// 各个用户产生的应用数据大小 (/lzcapp/var/userdata/$uid)
    #[prost(map = "string, uint64", tag = "5")]
    pub userdata: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    #[prost(uint64, tag = "6")]
    pub image: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPermission {
    /// 用户的 uid
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// 是否允许 uid 安装应用
    #[prost(bool, tag = "2")]
    pub allow_install_app: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserPermissionsRequest {
    /// 用户的 uid
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Appid {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActionUrlRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub appid: ::prost::alloc::string::String,
    #[prost(enumeration = "Action", tag = "3")]
    pub action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActionUrlResponse {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFileHandlerRequest {
    #[prost(string, tag = "1")]
    pub mimetype: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileHandlerInfo {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFileHandlerResponse {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<FileHandlerInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppInstance {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AppStatus {
    /// 应用未安装
    NotInstalled = 0,
    /// 应用下载中
    Downloading = 1,
    /// 应用下载被暂停
    Paused = 2,
    /// 应用安装中
    Installing = 3,
    /// 应用已安装
    Installed = 4,
    /// 应用安装失败
    Failed = 5,
}
impl AppStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotInstalled => "NotInstalled",
            Self::Downloading => "Downloading",
            Self::Paused => "Paused",
            Self::Installing => "Installing",
            Self::Installed => "Installed",
            Self::Failed => "Failed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NotInstalled" => Some(Self::NotInstalled),
            "Downloading" => Some(Self::Downloading),
            "Paused" => Some(Self::Paused),
            "Installing" => Some(Self::Installing),
            "Installed" => Some(Self::Installed),
            "Failed" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstanceStatus {
    StatusError = 0,
    StatusPaused = 1,
    StatusStopping = 2,
    StatusStarting = 3,
    StatusRunning = 4,
}
impl InstanceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StatusError => "Status_Error",
            Self::StatusPaused => "Status_Paused",
            Self::StatusStopping => "Status_Stopping",
            Self::StatusStarting => "Status_Starting",
            Self::StatusRunning => "Status_Running",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Status_Error" => Some(Self::StatusError),
            "Status_Paused" => Some(Self::StatusPaused),
            "Status_Stopping" => Some(Self::StatusStopping),
            "Status_Starting" => Some(Self::StatusStarting),
            "Status_Running" => Some(Self::StatusRunning),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Open = 0,
    New = 1,
    Download = 2,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Open => "Open",
            Self::New => "New",
            Self::Download => "Download",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Open" => Some(Self::Open),
            "New" => Some(Self::New),
            "Download" => Some(Self::Download),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod package_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct PackageManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PackageManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PackageManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PackageManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PackageManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 根据 URL 和 校验码（可选），安装应用
        pub async fn install(
            &mut self,
            request: impl tonic::IntoRequest<super::InstallRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/Install",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "Install"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据 AppId 卸载应用
        pub async fn uninstall(
            &mut self,
            request: impl tonic::IntoRequest<super::UninstallRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/Uninstall",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "Uninstall"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 休眠应用
        pub async fn pause(
            &mut self,
            request: impl tonic::IntoRequest<super::AppInstance>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/Pause",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "Pause"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 恢复应用
        pub async fn resume(
            &mut self,
            request: impl tonic::IntoRequest<super::AppInstance>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/Resume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "Resume"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据 AppId 清除缓存
        pub async fn clear_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::Appid>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/ClearCache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "ClearCache",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取 AppCfg
        pub async fn get_app_cfg(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAppCfgRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAppCfgResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/GetAppCfg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "GetAppCfg"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置 AppCfg
        pub async fn set_app_cfg(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAppCfgRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/SetAppCfg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.PackageManager", "SetAppCfg"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 查询用户安装的特定应用的详情
        pub async fn query_application(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/QueryApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "QueryApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取应用占用的存储空间详情
        pub async fn query_app_storage_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAppStorageUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AppStorageUsage>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/QueryAppStorageUsage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "QueryAppStorageUsage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置某个用户是否可以安装应用
        pub async fn set_user_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::UserPermission>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/SetUserPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "SetUserPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取某个用户安装应用的权限
        pub async fn get_user_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserPermissionsRequest>,
        ) -> std::result::Result<tonic::Response<super::UserPermission>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/GetUserPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "GetUserPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 暂停下载特定应用
        pub async fn pause_app_download(
            &mut self,
            request: impl tonic::IntoRequest<super::Appid>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/PauseAppDownload",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "PauseAppDownload",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取用某个应用打开某个文件的链接
        pub async fn get_action_url(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActionUrlRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetActionUrlResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/GetActionURL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "GetActionURL",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出可以打开指定 MIME 类型的应用
        pub async fn list_file_handler(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFileHandlerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFileHandlerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.PackageManager/ListFileHandler",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.PackageManager",
                        "ListFileHandler",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListOptRequest {
    #[prost(enumeration = "ListOptType", tag = "1")]
    pub opt: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppId {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceInfo {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub delete_all_data: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppIdList {
    #[prost(string, repeated, tag = "1")]
    pub app_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    #[prost(string, repeated, tag = "1")]
    pub app_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "ListOptType", tag = "2")]
    pub opt: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppMetadata {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub system: bool,
    #[prost(bool, tag = "3")]
    pub mutli_instance: bool,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppMetadataArray {
    #[prost(message, repeated, tag = "1")]
    pub metadata: ::prost::alloc::vec::Vec<AppMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusInfo {
    #[prost(enumeration = "status_info::StatusType", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub err_msg: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StatusInfo`.
pub mod status_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StatusType {
        Stopped = 0,
        Stopping = 1,
        Building = 2,
        Downloading = 3,
        Hooking = 4,
        Starting = 5,
        Running = 6,
        Insufficient = 7,
        Paused = 8,
        Dead = 9,
        Error = 10,
        Disabled = 11,
    }
    impl StatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Stopped => "STOPPED",
                Self::Stopping => "STOPPING",
                Self::Building => "BUILDING",
                Self::Downloading => "DOWNLOADING",
                Self::Hooking => "HOOKING",
                Self::Starting => "STARTING",
                Self::Running => "RUNNING",
                Self::Insufficient => "INSUFFICIENT",
                Self::Paused => "PAUSED",
                Self::Dead => "DEAD",
                Self::Error => "ERROR",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOPPED" => Some(Self::Stopped),
                "STOPPING" => Some(Self::Stopping),
                "BUILDING" => Some(Self::Building),
                "DOWNLOADING" => Some(Self::Downloading),
                "HOOKING" => Some(Self::Hooking),
                "STARTING" => Some(Self::Starting),
                "RUNNING" => Some(Self::Running),
                "INSUFFICIENT" => Some(Self::Insufficient),
                "PAUSED" => Some(Self::Paused),
                "DEAD" => Some(Self::Dead),
                "ERROR" => Some(Self::Error),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesStatus {
    #[prost(map = "string, message", tag = "1")]
    pub instances_status: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StatusInfo,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppsStatus {
    #[prost(map = "string, message", tag = "1")]
    pub apps_status: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstancesStatus,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawData {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ListOptType {
    /// 列出所有
    All = 0,
    /// 仅列出系统应用
    Sys = 1,
    /// 仅列出用户应用
    App = 2,
}
impl ListOptType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::All => "ALL",
            Self::Sys => "SYS",
            Self::App => "APP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALL" => Some(Self::All),
            "SYS" => Some(Self::Sys),
            "APP" => Some(Self::App),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod core_system_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct CoreSystemClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CoreSystemClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CoreSystemClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CoreSystemClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CoreSystemClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List 列出所有已安装的应用
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOptRequest>,
        ) -> std::result::Result<tonic::Response<super::AppIdList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Apply 安装或更新一个 app
        pub async fn apply(
            &mut self,
            request: impl tonic::IntoRequest<super::RawData>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Apply",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Apply"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn apply2(
            &mut self,
            request: impl tonic::IntoRequest<super::PkgUrl>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Apply2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Apply2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn apply3(
            &mut self,
            request: impl tonic::IntoRequest<super::PkgUrl>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Apply3",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Apply3"));
            self.inner.unary(req, path, codec).await
        }
        /// ApplyLpk 安装或更新一个 app (lpk 封装)
        pub async fn apply_lpk(
            &mut self,
            request: impl tonic::IntoRequest<super::PkgUrl>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/ApplyLpk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "ApplyLpk"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Remove 移除一个 app
        pub async fn remove(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Remove",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Remove"));
            self.inner.unary(req, path, codec).await
        }
        /// Disable 禁用一个 app
        pub async fn disable(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Disable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Disable"));
            self.inner.unary(req, path, codec).await
        }
        /// Enable 启用一个 app
        pub async fn enable(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Enable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Enable"));
            self.inner.unary(req, path, codec).await
        }
        /// Query 查询 app 的元信息
        pub async fn query(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AppMetadataArray>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Query",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Query"));
            self.inner.unary(req, path, codec).await
        }
        /// 查询所有 app 的所有实例状态
        pub async fn status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::AppsStatus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/Status",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "Status"));
            self.inner.unary(req, path, codec).await
        }
        /// 查询 app 的所有实例状态
        pub async fn app_status(
            &mut self,
            request: impl tonic::IntoRequest<super::AppId>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesStatus>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/AppStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "AppStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 查询实例状态
        pub async fn instance_status(
            &mut self,
            request: impl tonic::IntoRequest<super::InstanceInfo>,
        ) -> std::result::Result<tonic::Response<super::StatusInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/InstanceStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.CoreSystem",
                        "InstanceStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 添加一个实例
        pub async fn instance_add(
            &mut self,
            request: impl tonic::IntoRequest<super::InstanceInfo>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/InstanceAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "InstanceAdd"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 删除一个实例
        pub async fn instance_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::InstanceInfo>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/InstanceRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.CoreSystem",
                        "InstanceRemove",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 暂停一个实例
        pub async fn instance_pause(
            &mut self,
            request: impl tonic::IntoRequest<super::InstanceInfo>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/InstancePause",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.CoreSystem", "InstancePause"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 继续一个实例
        pub async fn instance_resume(
            &mut self,
            request: impl tonic::IntoRequest<super::InstanceInfo>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.CoreSystem/InstanceResume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.CoreSystem",
                        "InstanceResume",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppAccessPolicyRequest {
    /// 若为空则从context中获取实际UID
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub policy: ::core::option::Option<AppAccessPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppAccessPolicy {
    /// 是否允许访问所有应用。
    /// 此字段如果出现，则allow_access_apps字段会被忽略，即旧值不会有任何调整变化。
    ///
    /// 当目标用户有安装应用的权限时，无法设置no_limit=false。其他情况no_limit的值无任何限制。
    #[prost(bool, optional, tag = "1")]
    pub no_limit: ::core::option::Option<bool>,
    /// 允许访问的appid列表
    #[prost(string, repeated, tag = "2")]
    pub allow_access_appids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressAppLastAccessTimeRequest {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IngressAppLastAccessTimeResponse {
    #[prost(int64, tag = "1")]
    pub unix_time: i64,
}
/// Generated client implementations.
pub mod access_controler_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct AccessControlerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccessControlerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccessControlerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccessControlerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AccessControlerServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn set_app_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::AppAccessPolicyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.AccessControlerService/SetAppAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.AccessControlerService",
                        "SetAppAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_app_access_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::AppAccessPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AppAccessPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.AccessControlerService/QueryAppAccessPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.AccessControlerService",
                        "QueryAppAccessPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_app_last_access_time(
            &mut self,
            request: impl tonic::IntoRequest<super::IngressAppLastAccessTimeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IngressAppLastAccessTimeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.AccessControlerService/GetAppLastAccessTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.AccessControlerService",
                        "GetAppLastAccessTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfo {
    /// 热点的网卡 mac 地址（由于 ssid 可能重复，所以将此字段作为整个列表的 index）
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 热点的 ssid
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// 信号强度（范围 0 <= signal <= 100）
    #[prost(int32, tag = "3")]
    pub signal: i32,
    /// 信号频率
    #[prost(int32, tag = "9")]
    pub frequency: i32,
    /// 是否需要密码
    #[prost(bool, tag = "4")]
    pub security: bool,
    /// 是否已连接
    #[prost(bool, tag = "5")]
    pub connected: bool,
    /// 是否已保存密码
    #[prost(bool, tag = "6")]
    pub saved: bool,
    /// 是否自动连接
    #[prost(bool, tag = "7")]
    pub auto_connected: bool,
    /// 是否锁定 bssid （锁定后，不会自动连接其他同名不同 bssid 的热点）
    #[prost(bool, tag = "8")]
    pub bssid_locked: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfoList {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<AccessPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStatusInfo {
    /// 是否已连接到互联网
    #[prost(bool, tag = "1")]
    pub has_internet: bool,
    /// 有线连接状态（已假设只有一块有线网卡）
    #[prost(enumeration = "NetworkDeviceStatus", tag = "2")]
    pub wired_device: i32,
    /// 无线设备状态（已假设只有一块无线网卡）
    #[prost(enumeration = "NetworkDeviceStatus", tag = "3")]
    pub wireless_device: i32,
    /// 网络协商速率
    #[prost(int64, tag = "5")]
    pub link_speed: i64,
    /// 若无线设备已连接，则该字段表示已连接的 wifi 的信息
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<AccessPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConnectInfo {
    /// bssid 和 ssid 指定其一即可
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 当指定了 bssid 时，该值无效。所以要指定该值就不要指定 bssid
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// wifi 密码，如果 KeyMgmt 值是 KeyMgmtNone 则该值无效
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// 加密类型，该值一般不用指定，会自动嗅探，只有连接隐藏网络或手动添加网络才会用到此字段
    #[prost(enumeration = "KeyMgmt", optional, tag = "4")]
    pub key_mgmt: ::core::option::Option<i32>,
    /// 连接超时时间（单位：秒），如果不指定则为 NetworkManager 默认行为。
    /// 如果连接超时，会当作失败处理抛出异常
    #[prost(int64, optional, tag = "5")]
    pub timeout: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConnectTempInfo {
    /// 暂时连接的 bssid
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 到时间后自动连接的 bssid
    #[prost(string, tag = "2")]
    pub fallback_bssid: ::prost::alloc::string::String,
    /// 连接持续时间（单位：秒），到时间后会自动连接回之前的 bssid
    #[prost(int64, tag = "5")]
    pub duration: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiForgetInfo {
    #[prost(string, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConfigInfo {
    #[prost(string, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(enumeration = "KeyMgmt", tag = "3")]
    pub key_mgmt: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WifiConnectReply {
    #[prost(enumeration = "WifiConnectResult", tag = "1")]
    pub result: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkDeviceStatus {
    /// 不可用
    Unavailable = 0,
    /// 未连接
    Disconnected = 1,
    /// 正在连接
    Connecting = 2,
    /// 已连接
    Connected = 3,
    /// 正在断开
    Disconnecting = 4,
    /// 已禁用
    Disabled = 5,
}
impl NetworkDeviceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unavailable => "NetworkDeviceStatusUnavailable",
            Self::Disconnected => "NetworkDeviceStatusDisconnected",
            Self::Connecting => "NetworkDeviceStatusConnecting",
            Self::Connected => "NetworkDeviceStatusConnected",
            Self::Disconnecting => "NetworkDeviceStatusDisconnecting",
            Self::Disabled => "NetworkDeviceStatusDisabled",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NetworkDeviceStatusUnavailable" => Some(Self::Unavailable),
            "NetworkDeviceStatusDisconnected" => Some(Self::Disconnected),
            "NetworkDeviceStatusConnecting" => Some(Self::Connecting),
            "NetworkDeviceStatusConnected" => Some(Self::Connected),
            "NetworkDeviceStatusDisconnecting" => Some(Self::Disconnecting),
            "NetworkDeviceStatusDisabled" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyMgmt {
    None = 0,
    /// WEP  （最老的协议了，目前几乎没人用）
    Wep = 1,
    /// WPA/WPA2-Personal  （一般大概率都是这个，应当作为默认值）
    WpaPsk = 2,
    /// WPA3-Personal  （新一代协议，用的人比较少）
    Sae = 3,
}
impl KeyMgmt {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "KeyMgmtNone",
            Self::Wep => "KeyMgmtWEP",
            Self::WpaPsk => "KeyMgmtWPA_PSK",
            Self::Sae => "KeyMgmtSAE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KeyMgmtNone" => Some(Self::None),
            "KeyMgmtWEP" => Some(Self::Wep),
            "KeyMgmtWPA_PSK" => Some(Self::WpaPsk),
            "KeyMgmtSAE" => Some(Self::Sae),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WifiConnectResult {
    Success = 0,
    NoSuchBssid = 1,
    WrongPassword = 2,
    UnknownError = 3,
}
impl WifiConnectResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "WifiConnectResultSuccess",
            Self::NoSuchBssid => "WifiConnectResultNoSuchBssid",
            Self::WrongPassword => "WifiConnectResultWrongPassword",
            Self::UnknownError => "WifiConnectResultUnknownError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WifiConnectResultSuccess" => Some(Self::Success),
            "WifiConnectResultNoSuchBssid" => Some(Self::NoSuchBssid),
            "WifiConnectResultWrongPassword" => Some(Self::WrongPassword),
            "WifiConnectResultUnknownError" => Some(Self::UnknownError),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod network_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct NetworkManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NetworkManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NetworkManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NetworkManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 获取网络设备的状态（是否已连接，连接了哪个）
        pub async fn status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkDeviceStatusInfo>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/Status",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.NetworkManager", "Status"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Scan 扫描附近wifi热点信息，扫描结果在内部缓存里（阻塞，可能耗费数秒）
        pub async fn wifi_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.NetworkManager", "WifiScan"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List 列出内部缓存中的 wifi 列表
        pub async fn wifi_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::AccessPointInfoList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.NetworkManager", "WifiList"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 连接一个 wifi 热点
        ///   连接失败会删除已保存的配置，并自动连回上一次连接的 wifi（如果有的话），防止失联
        pub async fn wifi_connect(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConnectInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiConnect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.NetworkManager",
                        "WifiConnect",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 暂时连接一个 wifi 热点
        /// 时间到了之后会Revert回指定的 wifi 热点
        /// 如果在上一个调用的duration时间范围内再次调用，则会取消上次调用时间到后对fallback_bssid的连接
        pub async fn wifi_connect_temp(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConnectTempInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiConnectTemp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.NetworkManager",
                        "WifiConnectTemp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 忘记一个 wifi 热点
        pub async fn wifi_forget(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiForgetInfo>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiForget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.NetworkManager",
                        "WifiForget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 手动添加和连接一个 wifi 热点配置（用于连接隐藏网络）
        pub async fn wifi_config_add(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConfigInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.NetworkManager/WifiConfigAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.sys.NetworkManager",
                        "WifiConfigAdd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunRequest {
    #[prost(string, tag = "1")]
    pub image: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    #[prost(bool, tag = "1")]
    pub ready: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsHdmiConnectedResponse {
    #[prost(bool, tag = "1")]
    pub connected: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsLoggedInResponse {
    #[prost(bool, tag = "1")]
    pub is_logged_in: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBookmarkRequest {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Bookmark>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBookmarkResponse {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<BookmarkWitoutIcon>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelBookmarkRequest {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<BookmarkWitoutIcon>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBookmarkIconRequest {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<BookmarkWitoutIcon>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBookmarkIconResponse {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Bookmark>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BookmarkWitoutIcon {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bookmark {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod tv_os_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TvOsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TvOsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TvOsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TvOsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TvOsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 启动
        pub async fn run(
            &mut self,
            request: impl tonic::IntoRequest<super::RunRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/Run",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "Run"));
            self.inner.unary(req, path, codec).await
        }
        /// 状态
        pub async fn status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::StatusResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/Status",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "Status"));
            self.inner.unary(req, path, codec).await
        }
        /// 停止
        pub async fn stop(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/Stop",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "Stop"));
            self.inner.unary(req, path, codec).await
        }
        /// 是否连接HDMI
        pub async fn is_hdmi_connected(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::IsHdmiConnectedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/IsHDMIConnected",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "IsHDMIConnected"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 是否已登录
        pub async fn is_logged_in(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::IsLoggedInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/IsLoggedIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "IsLoggedIn"));
            self.inner.unary(req, path, codec).await
        }
        /// 添加书签
        pub async fn add_bookmark(
            &mut self,
            request: impl tonic::IntoRequest<super::AddBookmarkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/AddBookmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "AddBookmark"));
            self.inner.unary(req, path, codec).await
        }
        /// 列出书签
        pub async fn list_bookmark(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListBookmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/ListBookmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "ListBookmark"));
            self.inner.unary(req, path, codec).await
        }
        /// 删除书签
        pub async fn del_bookmark(
            &mut self,
            request: impl tonic::IntoRequest<super::DelBookmarkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/DelBookmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "DelBookmark"));
            self.inner.unary(req, path, codec).await
        }
        /// 列出书签icon
        pub async fn list_bookmark_icon(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBookmarkIconRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBookmarkIconResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/ListBookmarkIcon",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "ListBookmarkIcon"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 踢出当前登录的客户端
        /// 清理hportal-client缓存目录并重启容器
        pub async fn kick_logged_in(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.TvOS/KickLoggedIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cloud.lazycat.apis.sys.TvOS", "KickLoggedIn"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionInfo {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod version_info_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct VersionInfoServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VersionInfoServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VersionInfoServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VersionInfoServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            VersionInfoServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::VersionInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.sys.VersionInfoService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.sys.VersionInfoService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
