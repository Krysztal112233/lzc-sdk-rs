// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDiskListResponse {
    #[prost(message, repeated, tag = "1")]
    pub disks: ::prost::alloc::vec::Vec<BackupDiskDetail>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDiskDetail {
    /// 备份盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// 备份盘的名称
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// 硬盘的总容量
    #[prost(uint64, tag = "3")]
    pub size: u64,
    /// 硬盘可用空间
    #[prost(uint64, tag = "4")]
    pub avail: u64,
    /// 最早备份的时间
    #[prost(message, optional, tag = "5")]
    pub first_date: ::core::option::Option<::prost_types::Timestamp>,
    /// 最近备份的时间
    #[prost(message, optional, tag = "6")]
    pub latest_date: ::core::option::Option<::prost_types::Timestamp>,
    /// 当前备份盘的状态
    #[prost(enumeration = "BackupDiskStatus", tag = "7")]
    pub status: i32,
    /// 距离下一次备份的时间(单位为秒)
    #[prost(uint64, tag = "8")]
    pub next_backup_time: u64,
    /// 备份盘是否属于当前盒子（限制为一个盒子只能备份一个盒子中的数据，要不然数据会乱掉）
    #[prost(bool, tag = "9")]
    pub is_current_box: bool,
    /// 状态信息
    #[prost(string, tag = "10")]
    pub status_msg: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemovableDiskListResponse {
    #[prost(message, repeated, tag = "1")]
    pub disks: ::prost::alloc::vec::Vec<RemovableDiskDetail>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemovableDiskDetail {
    /// 硬盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// 硬盘的型号
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    /// 硬盘的总容量
    #[prost(uint64, tag = "3")]
    pub size: u64,
    /// 硬盘可用空间
    #[prost(uint64, tag = "4")]
    pub avail: u64,
    /// 硬盘路径(在 wipefs 后， device 可能会没有 uuid)
    #[prost(string, tag = "5")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormatToBackupDiskRequest {
    /// 需要格式化硬盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// 指定备份盘的显示的名称
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// 如果uuid为空，将使用 path 寻找对应的 device
    #[prost(string, optional, tag = "3")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRequest {
    /// 指定备份的盘
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupResponse {
    /// 备份的大小
    #[prost(uint64, tag = "1")]
    pub total: u64,
    /// 备份的速度
    #[prost(uint64, tag = "2")]
    pub speed: u64,
    /// 已备份的大小
    #[prost(uint64, tag = "3")]
    pub finished: u64,
    #[prost(enumeration = "backup_response::Status", tag = "4")]
    pub status: i32,
}
/// Nested message and enum types in `BackupResponse`.
pub mod backup_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// 配置完成
        Config = 0,
        /// 准备中
        Prepare = 1,
        /// 开始备份
        Begin = 2,
        /// 拷贝中
        Copying = 3,
        /// 备份完成
        Done = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Config => "Config",
                Self::Prepare => "Prepare",
                Self::Begin => "Begin",
                Self::Copying => "Copying",
                Self::Done => "Done",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Config" => Some(Self::Config),
                "Prepare" => Some(Self::Prepare),
                "Begin" => Some(Self::Begin),
                "Copying" => Some(Self::Copying),
                "Done" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDataListResponse {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<BackupRestoreUserData>,
    #[prost(message, repeated, tag = "2")]
    pub apps: ::prost::alloc::vec::Vec<BackupRestoreAppData>,
    #[prost(message, optional, tag = "3")]
    pub os: ::core::option::Option<BackupRestoreOsData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRestoreUserData {
    /// 用户 id
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// 使用数据大小
    #[prost(uint64, tag = "2")]
    pub used: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRestoreAppData {
    /// 应用id
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    /// 应用名称
    #[prost(string, tag = "2")]
    pub app_name: ::prost::alloc::string::String,
    /// 应用使用数据大小
    #[prost(uint64, tag = "3")]
    pub used: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupRestoreOsData {
    /// 系统使用数据大小
    #[prost(uint64, tag = "1")]
    pub used: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavepointsRequest {
    /// 硬盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavepointsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datas: ::prost::alloc::vec::Vec<SavepointDetail>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavepointDetail {
    /// 时间点
    #[prost(message, optional, tag = "1")]
    pub date: ::core::option::Option<::prost_types::Timestamp>,
    /// 用户文稿数据详情
    #[prost(message, repeated, tag = "2")]
    pub users: ::prost::alloc::vec::Vec<BackupRestoreUserData>,
    /// 应用数据
    #[prost(message, repeated, tag = "3")]
    pub apps: ::prost::alloc::vec::Vec<BackupRestoreAppData>,
    /// 系统数据
    #[prost(message, optional, tag = "4")]
    pub os: ::core::option::Option<BackupRestoreOsData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreRequest {
    /// 硬盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// 需要还原的时间点
    #[prost(message, optional, tag = "2")]
    pub date: ::core::option::Option<::prost_types::Timestamp>,
    /// 指定需要还原的部分数据，按照当前的设计，这里只需要布尔值判断即可
    #[prost(bool, tag = "3")]
    pub users: bool,
    #[prost(bool, tag = "4")]
    pub apps: bool,
    #[prost(bool, tag = "5")]
    pub os: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestoreResponse {
    /// 总大小
    #[prost(uint64, tag = "1")]
    pub total: u64,
    /// 速度
    #[prost(uint64, tag = "2")]
    pub speed: u64,
    /// 已完成大小
    #[prost(uint64, tag = "3")]
    pub finished: u64,
    /// 还原的项目详情
    #[prost(message, optional, tag = "4")]
    pub detail: ::core::option::Option<RestoreResponseInfo>,
    /// 还原所花费的时间，从开始到当前状态的间隔(单位为秒)
    #[prost(uint64, tag = "5")]
    pub spend_time: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestoreResponseInfo {
    #[prost(enumeration = "restore_response_info::Item", tag = "1")]
    pub item: i32,
    #[prost(enumeration = "restore_response_info::Status", tag = "2")]
    pub status: i32,
}
/// Nested message and enum types in `RestoreResponseInfo`.
pub mod restore_response_info {
    /// 表示当前正在处理的项目，结合Status展示
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Item {
        Lpk = 0,
        UserDocument = 1,
        App = 2,
        Lzcos = 3,
        Baseos = 4,
    }
    impl Item {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Lpk => "Lpk",
                Self::UserDocument => "UserDocument",
                Self::App => "App",
                Self::Lzcos => "Lzcos",
                Self::Baseos => "Baseos",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Lpk" => Some(Self::Lpk),
                "UserDocument" => Some(Self::UserDocument),
                "App" => Some(Self::App),
                "Lzcos" => Some(Self::Lzcos),
                "Baseos" => Some(Self::Baseos),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// 准备中
        Prepare = 0,
        /// 开始还原
        Begin = 1,
        /// 拷贝中
        Copying = 2,
        /// 还原中
        Restoring = 3,
        /// 重启runtime (如果没有还原系统配置，就只会重启runtime，否则将直接重启lzcos)
        RestartRuntime = 4,
        /// 重启系统
        Reboot = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Prepare => "Prepare",
                Self::Begin => "Begin",
                Self::Copying => "Copying",
                Self::Restoring => "Restoring",
                Self::RestartRuntime => "RestartRuntime",
                Self::Reboot => "Reboot",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Prepare" => Some(Self::Prepare),
                "Begin" => Some(Self::Begin),
                "Copying" => Some(Self::Copying),
                "Restoring" => Some(Self::Restoring),
                "RestartRuntime" => Some(Self::RestartRuntime),
                "Reboot" => Some(Self::Reboot),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EjectRequest {
    /// 硬盘的uuid
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupDiskStatus {
    /// 空闲中
    Idel = 0,
    /// 备份中
    Backuping = 1,
    /// 未配置（用于用户格式化成懒猫备份盘，但还没有配置备份策略的情况）
    NotConfig = 2,
    /// 备份错误
    Error = 3,
    /// 没有空间
    NoSpace = 4,
    /// 还原中
    Restoring = 5,
    /// 暂停中
    Paused = 6,
}
impl BackupDiskStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Idel => "Idel",
            Self::Backuping => "Backuping",
            Self::NotConfig => "NotConfig",
            Self::Error => "Error",
            Self::NoSpace => "NoSpace",
            Self::Restoring => "Restoring",
            Self::Paused => "Paused",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Idel" => Some(Self::Idel),
            "Backuping" => Some(Self::Backuping),
            "NotConfig" => Some(Self::NotConfig),
            "Error" => Some(Self::Error),
            "NoSpace" => Some(Self::NoSpace),
            "Restoring" => Some(Self::Restoring),
            "Paused" => Some(Self::Paused),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod backup_restore_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BackupRestoreServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BackupRestoreServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BackupRestoreServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackupRestoreServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BackupRestoreServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 获取当前接在盒子上的备份盘列表
        pub async fn backup_disk_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::BackupDiskListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/BackupDiskList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "BackupDiskList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取当前接在盒子上所有的可插拔硬盘设备列表
        pub async fn removable_disk_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::RemovableDiskListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/RemovableDiskList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "RemovableDiskList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 格式化硬盘为懒猫微服备份盘
        pub async fn format_to_backup_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::FormatToBackupDiskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/FormatToBackupDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "FormatToBackupDisk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 开始备份，如果指定的备份盘正在处于备份中，将返回当前备份的状态信息
        pub async fn backup(
            &mut self,
            request: impl tonic::IntoRequest<super::BackupRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BackupResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/Backup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "Backup",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 获取支持备份的数据列表
        pub async fn backup_data_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::BackupDataListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/BackupDataList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "BackupDataList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取指定备份盘上的所有还原点
        pub async fn savepoints(
            &mut self,
            request: impl tonic::IntoRequest<super::SavepointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SavepointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/Savepoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "Savepoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 开始还原，如果指定的备份盘正处于还原中，将返回当前还原的状态信息
        pub async fn restore(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RestoreResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/Restore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "Restore",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 推出指定的设备
        pub async fn eject(
            &mut self,
            request: impl tonic::IntoRequest<super::EjectRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.BackupRestoreService/Eject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.BackupRestoreService",
                        "Eject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsBoxSetupFinishResponse {
    #[prost(bool, tag = "1")]
    pub finish: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptTestRequest {
    #[prost(string, tag = "1")]
    pub passwd: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterBoxResponse {
    /// 初始化成功
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// 失败原因
    #[prost(string, optional, tag = "2")]
    pub failed_reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterBoxRequest {
    /// 微服名
    #[prost(string, tag = "1")]
    pub boxname: ::prost::alloc::string::String,
    /// 管理员名
    #[prost(string, tag = "2")]
    pub user: ::prost::alloc::string::String,
    /// 密码
    #[prost(string, tag = "3")]
    pub passwd: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ButtonTestReply {
    /// 按钮状态
    #[prost(enumeration = "button_test_reply::Status", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `ButtonTestReply`.
pub mod button_test_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// 等待按下
        Pending = 0,
        /// 按钮被按下
        Pressed = 1,
        /// 等待超时
        Timeout = 2,
        /// 结束
        Done = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Pending => "Pending",
                Self::Pressed => "Pressed",
                Self::Timeout => "Timeout",
                Self::Done => "Done",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Pending" => Some(Self::Pending),
                "Pressed" => Some(Self::Pressed),
                "Timeout" => Some(Self::Timeout),
                "Done" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConnectInfo {
    /// bssid 和 ssid 指定其一即可
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    #[prost(enumeration = "KeyMgmt", optional, tag = "4")]
    pub key_mgmt: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WifiConnectReply {
    #[prost(enumeration = "WifiConnectResult", tag = "1")]
    pub result: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfoList {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<AccessPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfo {
    /// 热点的网卡 mac 地址（由于 ssid 可能重复，所以将此字段作为整个列表的 index）
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 热点的 ssid
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// 信号强度（范围 0 <= signal <= 100）
    #[prost(int32, tag = "3")]
    pub signal: i32,
    /// 是否需要密码
    #[prost(bool, tag = "4")]
    pub security: bool,
    /// 是否已连接
    #[prost(bool, tag = "5")]
    pub connected: bool,
    /// 是否已保存密码
    #[prost(bool, tag = "6")]
    pub saved: bool,
    /// 是否自动连接
    #[prost(bool, tag = "7")]
    pub auto_connected: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStatusInfoRespone {
    /// 是否有互联网
    #[prost(bool, tag = "1")]
    pub has_internet: bool,
    /// 有线连接状态（已假设只有一块有线网卡）
    #[prost(enumeration = "network_device_status_info_respone::Status", tag = "2")]
    pub wired_device: i32,
    /// 无线设备状态（已假设只有一块无线网卡）
    #[prost(enumeration = "network_device_status_info_respone::Status", tag = "3")]
    pub wireless_device: i32,
}
/// Nested message and enum types in `NetworkDeviceStatusInfoRespone`.
pub mod network_device_status_info_respone {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Disconnected = 0,
        Connecting = 1,
        Connected = 2,
        Disconnecting = 3,
        Disabled = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Disconnected => "Disconnected",
                Self::Connecting => "Connecting",
                Self::Connected => "Connected",
                Self::Disconnecting => "Disconnecting",
                Self::Disabled => "Disabled",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Disconnected" => Some(Self::Disconnected),
                "Connecting" => Some(Self::Connecting),
                "Connected" => Some(Self::Connected),
                "Disconnecting" => Some(Self::Disconnecting),
                "Disabled" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxNameRegisteredRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BoxNameRegisteredReply {
    #[prost(enumeration = "box_name_registered_reply::Status", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `BoxNameRegisteredReply`.
pub mod box_name_registered_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        NotAvailable = 0,
        Ok = 1,
        NeedRecycle = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotAvailable => "NOT_AVAILABLE",
                Self::Ok => "OK",
                Self::NeedRecycle => "NEED_RECYCLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_AVAILABLE" => Some(Self::NotAvailable),
                "OK" => Some(Self::Ok),
                "NEED_RECYCLE" => Some(Self::NeedRecycle),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxSetupRequest {
    #[prost(string, tag = "1")]
    pub origin_server: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub box_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub user_info: ::core::option::Option<box_setup_request::UserInfo>,
    #[prost(message, optional, tag = "4")]
    pub disk_info: ::core::option::Option<box_setup_request::DiskInfo>,
}
/// Nested message and enum types in `BoxSetupRequest`.
pub mod box_setup_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserInfo {
        #[prost(string, tag = "1")]
        pub username: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub password: ::prost::alloc::string::String,
        #[prost(string, optional, tag = "3")]
        pub phonenumber: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// 此处 copy 自 ./proto/recovery/box-status.proto ，请在修改时保持同步
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiskInfo {
        #[prost(string, tag = "1")]
        pub password: ::prost::alloc::string::String,
        /// 是否使用 bcache
        #[prost(bool, tag = "3")]
        pub bcache: bool,
        #[prost(enumeration = "disk_info::Profile", tag = "4")]
        pub data_profile: i32,
        #[prost(enumeration = "disk_info::Profile", tag = "5")]
        pub metadata_profile: i32,
    }
    /// Nested message and enum types in `DiskInfo`.
    pub mod disk_info {
        /// 磁盘阵列 raid 相关
        /// btrfs 对此选项的标准全称叫作 "block group profile"
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Profile {
            /// 不主动设置，即使用 btrfs 默认，当前默认是 data=single, metadata=dup
            Unknown = 0,
            Raid0 = 1,
            Raid1 = 2,
            Single = 3,
            Dup = 4,
        }
        impl Profile {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "Unknown",
                    Self::Raid0 => "Raid0",
                    Self::Raid1 => "Raid1",
                    Self::Single => "Single",
                    Self::Dup => "Dup",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Unknown" => Some(Self::Unknown),
                    "Raid0" => Some(Self::Raid0),
                    "Raid1" => Some(Self::Raid1),
                    "Single" => Some(Self::Single),
                    "Dup" => Some(Self::Dup),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxSetupReply {
    #[prost(enumeration = "box_setup_reply::Status", tag = "1")]
    pub status: i32,
    #[prost(enumeration = "box_setup_reply::FailedStatus", optional, tag = "2")]
    pub failed_status: ::core::option::Option<i32>,
    /// 如果是InitializeFailed，那么可能有如下失败原因
    /// 微服名被别人注册了
    /// 微服名不符合规范
    /// 账号密码不符合规范
    /// 其他的失败就直接用其字面意思就行
    #[prost(string, optional, tag = "3")]
    pub failed_reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BoxSetupReply`.
pub mod box_setup_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// 等待按钮点击
        PendingButtonClick = 0,
        /// 初始化中，进行申请证书/域名等操作
        Initializing = 1,
        /// 失败
        Failed = 2,
        /// 成功
        Success = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PendingButtonClick => "PendingButtonClick",
                Self::Initializing => "Initializing",
                Self::Failed => "Failed",
                Self::Success => "Success",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PendingButtonClick" => Some(Self::PendingButtonClick),
                "Initializing" => Some(Self::Initializing),
                "Failed" => Some(Self::Failed),
                "Success" => Some(Self::Success),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailedStatus {
        /// 等待点击按钮超时
        WaitButtonTimeout = 0,
        /// 初始化失败
        InitializeFailed = 1,
    }
    impl FailedStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::WaitButtonTimeout => "WaitButtonTimeout",
                Self::InitializeFailed => "InitializeFailed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WaitButtonTimeout" => Some(Self::WaitButtonTimeout),
                "InitializeFailed" => Some(Self::InitializeFailed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HasInternetResponse {
    #[prost(bool, tag = "1")]
    pub result: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyMgmt {
    None = 0,
    /// WEP  （最老的协议了，目前几乎没人用）
    Wep = 1,
    /// WPA/WPA2-Personal  （一般大概率都是这个，应当作为默认值）
    WpaPsk = 2,
    /// WPA3-Personal  （新一代协议，用的人比较少）
    Sae = 3,
}
impl KeyMgmt {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "KeyMgmtNone",
            Self::Wep => "KeyMgmtWEP",
            Self::WpaPsk => "KeyMgmtWPA_PSK",
            Self::Sae => "KeyMgmtSAE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KeyMgmtNone" => Some(Self::None),
            "KeyMgmtWEP" => Some(Self::Wep),
            "KeyMgmtWPA_PSK" => Some(Self::WpaPsk),
            "KeyMgmtSAE" => Some(Self::Sae),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WifiConnectResult {
    Success = 0,
    NoSuchBssid = 1,
    WrongPassword = 2,
    UnknownError = 3,
}
impl WifiConnectResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "WifiConnectResultSuccess",
            Self::NoSuchBssid => "WifiConnectResultNoSuchBssid",
            Self::WrongPassword => "WifiConnectResultWrongPassword",
            Self::UnknownError => "WifiConnectResultUnknownError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WifiConnectResultSuccess" => Some(Self::Success),
            "WifiConnectResultNoSuchBssid" => Some(Self::NoSuchBssid),
            "WifiConnectResultWrongPassword" => Some(Self::WrongPassword),
            "WifiConnectResultUnknownError" => Some(Self::UnknownError),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod installer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct InstallerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InstallerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InstallerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstallerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            InstallerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 初始化微服
        pub async fn box_name_registered(
            &mut self,
            request: impl tonic::IntoRequest<super::BoxNameRegisteredRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BoxNameRegisteredReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/BoxNameRegistered",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "BoxNameRegistered",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 初始化微服
        pub async fn box_setup(
            &mut self,
            request: impl tonic::IntoRequest<super::BoxSetupRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BoxSetupReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/BoxSetup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "BoxSetup",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 微服是否有互联网
        pub async fn has_internet(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::HasInternetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/HasInternet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "HasInternet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出内部缓存中的 Wi-Fi 列表， 如果没有则会扫描后返回
        pub async fn wifi_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::AccessPointInfoList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/WifiList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "WifiList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 连接Wi-Fi
        pub async fn wifi_connect(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConnectInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/WifiConnect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "WifiConnect",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Scan 扫描盒子附近Wi-Fi热点信息，扫描结果在内部缓存里（阻塞，可能耗费数秒）
        pub async fn wifi_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/WifiScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "WifiScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 当前连接的Wi-Fi
        pub async fn wifi_get_connected(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::AccessPointInfo>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/WifiGetConnected",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "WifiGetConnected",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取网络设备的状态信息
        pub async fn network_device_status_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkDeviceStatusInfoRespone>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/NetworkDeviceStatusInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "NetworkDeviceStatusInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Ping? Pong!
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/Ping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "Ping",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 微服是否初始化结束
        pub async fn is_box_setup_finish(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::IsBoxSetupFinishResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.installer.InstallerService/IsBoxSetupFinish",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.installer.InstallerService",
                        "IsBoxSetupFinish",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
