// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClientInfoResponse {
    /// 设备客户端版本名字
    #[prost(string, tag = "1")]
    pub version_name: ::prost::alloc::string::String,
    /// 设备版本编码
    #[prost(int64, tag = "2")]
    pub client_code: i64,
}
/// Generated client implementations.
pub mod client_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ClientClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ClientClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ClientClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ClientClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ClientClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_client_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetClientInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Client/GetClientInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.Client",
                        "GetClientInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadClipRequest {
    /// 目前只支持text/plain和image/png
    #[prost(string, tag = "1")]
    pub mime: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadClipResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteClipRequest {
    #[prost(string, tag = "1")]
    pub mime: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteClipResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Generated client implementations.
pub mod clipboard_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ClipboardManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ClipboardManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ClipboardManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ClipboardManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ClipboardManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadClipRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadClipResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ClipboardManager/Read",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ClipboardManager",
                        "Read",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn write(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteClipRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteClipResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ClipboardManager/Write",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ClipboardManager",
                        "Write",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn watch(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadClipRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReadClipResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ClipboardManager/Watch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ClipboardManager",
                        "Watch",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpenFileReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableAutoMountRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableAutoMountReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsEnableAutoMountRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsEnableAutoMountReply {
    #[prost(bool, tag = "1")]
    pub enable: bool,
}
/// Generated client implementations.
pub mod cloud_driver_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct CloudDriverClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CloudDriverClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CloudDriverClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CloudDriverClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CloudDriverClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn enable_auto_mount(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableAutoMountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnableAutoMountReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.CloudDriver/EnableAutoMount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.CloudDriver",
                        "EnableAutoMount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn is_enable_auto_mount(
            &mut self,
            request: impl tonic::IntoRequest<super::IsEnableAutoMountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IsEnableAutoMountReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.CloudDriver/IsEnableAutoMount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.CloudDriver",
                        "IsEnableAutoMount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn open_file(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenFileRequest>,
        ) -> std::result::Result<tonic::Response<super::OpenFileReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.CloudDriver/OpenFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.CloudDriver",
                        "OpenFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUserConfigRequest {
    #[prost(string, tag = "1")]
    pub box_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub config_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub config_value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUserConfigResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserConfigRequest {
    #[prost(string, tag = "1")]
    pub box_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub config_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserConfigResponse {
    #[prost(string, tag = "1")]
    pub config_value: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod user_config_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UserConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserConfigClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_user_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.UserConfig/GetUserConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.UserConfig",
                        "GetUserConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_user_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUserConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetUserConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.UserConfig/SetUserConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.UserConfig",
                        "SetUserConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub phones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewContact {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub phones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContactsReply {
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContactsRequest {
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<NewContact>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddContactsReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContactsRequest {
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContactsReply {
    /// 删除失败的 id
    #[prost(string, repeated, tag = "1")]
    pub failed_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContactsRequest {
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContactsReply {
    /// 修改失败的 id
    #[prost(string, repeated, tag = "1")]
    pub failed_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetContactsCountRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetContactsCountReply {
    #[prost(int64, tag = "1")]
    pub count: i64,
}
/// Generated client implementations.
pub mod contacts_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ContactsManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContactsManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContactsManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContactsManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContactsManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 获取全部联系人列表
        pub async fn list_contacts(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListContactsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ContactsManager/ListContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ContactsManager",
                        "ListContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 添加联系人到通讯录
        pub async fn add_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::AddContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddContactsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ContactsManager/AddContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ContactsManager",
                        "AddContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 从通讯录删除联系人
        pub async fn delete_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteContactsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ContactsManager/DeleteContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ContactsManager",
                        "DeleteContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 修改通讯录的联系人
        pub async fn update_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateContactsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ContactsManager/UpdateContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ContactsManager",
                        "UpdateContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取联系人的数量
        pub async fn get_contacts_count(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContactsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetContactsCountReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.ContactsManager/GetContactsCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.ContactsManager",
                        "GetContactsCount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(string, tag = "1")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cpu: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub document_root_dir: ::prost::alloc::string::String,
    /// 用于扫码或辅助登录标记操作端
    #[prost(string, optional, tag = "5")]
    pub identity_provider: ::core::option::Option<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod device_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DeviceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeviceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeviceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeviceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeviceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn query(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::DeviceInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.DeviceService/Query",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.DeviceService",
                        "Query",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionRequest {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub default_cancel: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionResult {
    #[prost(bool, tag = "1")]
    pub yes: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageBoxRequest {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordRequest {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResult {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub ok: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileSeletorRequest {
    /// 选择类型
    #[prost(enumeration = "open_file_seletor_request::SelectType", tag = "1")]
    pub r#type: i32,
    /// 是否多选（多选在SelectType 为Dir时无效）
    #[prost(bool, tag = "2")]
    pub is_single: bool,
    /// 文件后缀过滤器
    /// 使用2种类型
    /// 第一种 jpb,png,mp3，指定文件的后缀名,使用,分割
    /// 支持的大类型有必须 image/* , 或者image/*,audio/*,video/*,document/*, 四种大类可以写在一起，也可以分开写,使用,分割。 如何该字段为空，则不过滤
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OpenFileSeletorRequest`.
pub mod open_file_seletor_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SelectType {
        Dir = 0,
        File = 1,
    }
    impl SelectType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Dir => "Dir",
                Self::File => "File",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Dir" => Some(Self::Dir),
                "File" => Some(Self::File),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileSeletorResult {
    /// 文件或者目录的路径, 如果是文件就是文件的全路径 比如 /home/lnks/1.jpg ,如果是目录就是目录的全路径,并且末尾以/结尾, 比如/home/lnks/
    #[prost(string, repeated, tag = "1")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod dialog_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DialogManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DialogManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DialogManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DialogManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DialogManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn question(
            &mut self,
            request: impl tonic::IntoRequest<super::QuestionRequest>,
        ) -> std::result::Result<tonic::Response<super::QuestionResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.DialogManager/Question",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.DialogManager",
                        "Question",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn message_box(
            &mut self,
            request: impl tonic::IntoRequest<super::MessageBoxRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.DialogManager/MessageBox",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.DialogManager",
                        "MessageBox",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn password(
            &mut self,
            request: impl tonic::IntoRequest<super::PasswordRequest>,
        ) -> std::result::Result<tonic::Response<super::PasswordResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.DialogManager/Password",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.DialogManager",
                        "Password",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn open_file_seletor(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenFileSeletorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenFileSeletorResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.DialogManager/OpenFileSeletor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.DialogManager",
                        "OpenFileSeletor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PinAppRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub app_name: ::prost::alloc::string::String,
    /// icon地址允许是http类型或者base64类型,如果为空将尝试获取网站的favicon.ico
    #[prost(string, tag = "3")]
    pub icon_url: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PinAppReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnPinAppRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnPinAppReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenAppRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_full_screen: bool,
    #[prost(string, tag = "3")]
    pub appid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub icon: ::prost::alloc::string::String,
    /// 当已经存在当前地址的窗口的时候，是否要求使用该地址强制打开。
    /// 使用场景，比如播放器存在已经存在，这个时候需要使用过新的链接打开，然后覆盖上一次的播放界面，然后指定forceOpen=true即可.
    #[prost(bool, tag = "7")]
    pub force_open: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpenAppReply {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenUnsafeAppRequest {
    /// control-view的地址
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// control-view的位置
    #[prost(enumeration = "open_unsafe_app_request::Position", tag = "2")]
    pub position: i32,
    /// control-view的高度(当control-view 在左右的时候表示宽度， 上下表示高度）
    ///
    /// 10%; 50px;
    #[prost(string, tag = "3")]
    pub height: ::prost::alloc::string::String,
    ///
    /// 此外control-view会接收以下特殊事件, 所有事件均统一以post-message形式发送， msg格式为`{ type: string, msg: string }`
    /// control-view需要自行调用addEventListener('message'), 并过滤type==lzc_control_api类型的message.
    ///
    /// 1. OnURLChange(new_url)
    /// 2. OnNewLinkClick(url)
    /// 3. OnDownloadLinkRequest(url)
    /// 4. OnNewResourceLink(url) 将所有的content-view请求的url通知给control-view
    /// 5. OnContentMessage(msg string) //在content-view中调用post-message发送的任何消息
    #[prost(enumeration = "open_unsafe_app_request::Feature", repeated, tag = "4")]
    pub features: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `OpenUnsafeAppRequest`.
pub mod open_unsafe_app_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Position {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3,
    }
    impl Position {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Left => "Left",
                Self::Right => "Right",
                Self::Top => "Top",
                Self::Bottom => "Bottom",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Left" => Some(Self::Left),
                "Right" => Some(Self::Right),
                "Top" => Some(Self::Top),
                "Bottom" => Some(Self::Bottom),
                _ => None,
            }
        }
    }
    /// 所有的功能都通过 window.lzc_control_api对象注入. (后面以$API代指)
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Feature {
        /// $API.InjectContentJS(jscontent,callback)  content-view 执行的jscontent, 如果有结果，会将结果通过callback(result:Boolean): 通知给control-view
        InjectJs = 0,
        /// $API.ReadCookie(domain) -> string  读取content-view cookie
        ReadCookie = 1,
    }
    impl Feature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InjectJs => "InjectJS",
                Self::ReadCookie => "ReadCookie",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "InjectJS" => Some(Self::InjectJs),
                "ReadCookie" => Some(Self::ReadCookie),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpenAppMethodRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpenAppMethodReply {
    /// 当前设备支持的应用打开方式
    #[prost(enumeration = "open_app_method_reply::Mode", tag = "1")]
    pub support: i32,
}
/// Nested message and enum types in `OpenAppMethodReply`.
pub mod open_app_method_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        All = 0,
        AllNot = 1,
        Browser = 2,
        Client = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "All",
                Self::AllNot => "AllNot",
                Self::Browser => "Browser",
                Self::Client => "Client",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "All" => Some(Self::All),
                "AllNot" => Some(Self::AllNot),
                "Browser" => Some(Self::Browser),
                "Client" => Some(Self::Client),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod local_launch_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LocalLaunchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LocalLaunchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LocalLaunchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LocalLaunchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LocalLaunchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 创建快捷方式
        pub async fn pin_app(
            &mut self,
            request: impl tonic::IntoRequest<super::PinAppRequest>,
        ) -> std::result::Result<tonic::Response<super::PinAppReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.LocalLaunchService/PinApp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.LocalLaunchService",
                        "PinApp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 删除快捷方式
        pub async fn un_pin_app(
            &mut self,
            request: impl tonic::IntoRequest<super::UnPinAppRequest>,
        ) -> std::result::Result<tonic::Response<super::UnPinAppReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.LocalLaunchService/UnPinApp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.LocalLaunchService",
                        "UnPinApp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 打开指定的懒猫云应用
        pub async fn open_app(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenAppRequest>,
        ) -> std::result::Result<tonic::Response<super::OpenAppReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.LocalLaunchService/OpenApp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.LocalLaunchService",
                        "OpenApp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 使用不安全模式打开指定APP
        /// App页面由两个webview组成：一个control-view,一个content-view
        /// 其中app渲染在control-view中，content-view的内容由App代码控制
        pub async fn open_unsafe_app(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenUnsafeAppRequest>,
        ) -> std::result::Result<tonic::Response<super::OpenAppReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.LocalLaunchService/OpenUnsafeApp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.LocalLaunchService",
                        "OpenUnsafeApp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 当前设备支持的应用打开方式
        pub async fn open_app_method(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenAppMethodRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenAppMethodReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.LocalLaunchService/OpenAppMethod",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.LocalLaunchService",
                        "OpenAppMethod",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkInformation {
    #[prost(enumeration = "ConnectionType", tag = "1")]
    pub ctype: i32,
    #[prost(bool, tag = "2")]
    pub is_online: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectionType {
    Unknown = 0,
    CellNone = 1,
    Ethernet = 2,
    Wifi = 3,
    Cell = 4,
    Cell2g = 5,
    Cell3g = 6,
    Cell4g = 7,
    Cell5g = 8,
}
impl ConnectionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::CellNone => "CELL_NONE",
            Self::Ethernet => "ETHERNET",
            Self::Wifi => "WIFI",
            Self::Cell => "CELL",
            Self::Cell2g => "CELL_2G",
            Self::Cell3g => "CELL_3G",
            Self::Cell4g => "CELL_4G",
            Self::Cell5g => "CELL_5G",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "CELL_NONE" => Some(Self::CellNone),
            "ETHERNET" => Some(Self::Ethernet),
            "WIFI" => Some(Self::Wifi),
            "CELL" => Some(Self::Cell),
            "CELL_2G" => Some(Self::Cell2g),
            "CELL_3G" => Some(Self::Cell3g),
            "CELL_4G" => Some(Self::Cell4g),
            "CELL_5G" => Some(Self::Cell5g),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod network_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct NetworkManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NetworkManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NetworkManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NetworkManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn query(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkInformation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.NetworkManager/Query",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.NetworkManager",
                        "Query",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestSyncDir {
    #[prost(string, tag = "1")]
    pub dir: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncDirOwner {
    #[prost(string, tag = "1")]
    pub box_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncDir {
    /// 需要同步的目录
    #[prost(string, tag = "1")]
    pub dir: ::prost::alloc::string::String,
    /// 当前同步状态
    #[prost(enumeration = "SyncStatus", tag = "2")]
    pub status: i32,
    /// 最后变化时间
    #[prost(message, optional, tag = "3")]
    pub last_modified_time: ::core::option::Option<::prost_types::Timestamp>,
    /// 所属者(属于哪个盒子和用户)
    #[prost(message, optional, tag = "4")]
    pub owner: ::core::option::Option<SyncDirOwner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseListSyncDir {
    #[prost(message, repeated, tag = "1")]
    pub dirs: ::prost::alloc::vec::Vec<SyncDir>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncStatus {
    /// 就绪
    Ready = 0,
    /// 同步中
    Syncing = 1,
    /// 失败
    Fail = 2,
    /// 失联
    UnRef = 3,
    /// 完成
    Finish = 4,
}
impl SyncStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ready => "Ready",
            Self::Syncing => "Syncing",
            Self::Fail => "Fail",
            Self::UnRef => "UnRef",
            Self::Finish => "Finish",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Ready" => Some(Self::Ready),
            "Syncing" => Some(Self::Syncing),
            "Fail" => Some(Self::Fail),
            "UnRef" => Some(Self::UnRef),
            "Finish" => Some(Self::Finish),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod oneway_sync_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct OnewaySyncClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OnewaySyncClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OnewaySyncClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OnewaySyncClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OnewaySyncClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 列出所有符合来源微服和用户的同步目录j
        pub async fn list_sync_dir(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestSyncDir>,
        ) -> std::result::Result<
            tonic::Response<super::ResponseListSyncDir>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.OnewaySync/ListSyncDir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.OnewaySync",
                        "ListSyncDir",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 新建一个同步目录
        pub async fn new_sync_dir(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestSyncDir>,
        ) -> std::result::Result<tonic::Response<super::SyncDir>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.OnewaySync/NewSyncDir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.OnewaySync",
                        "NewSyncDir",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 主动做一次同步，目标是来源微服和来源用户的同步目录
        pub async fn do_sync(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::SyncDir>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.OnewaySync/DoSync",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.OnewaySync",
                        "DoSync",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PermissionRequest {
    #[prost(enumeration = "Permission", tag = "1")]
    pub permission: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PermissionReply {
    #[prost(bool, tag = "1")]
    pub result: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPermissionsReply {
    /// map<Permission, bool>
    #[prost(map = "int32, bool", tag = "1")]
    pub result: ::std::collections::HashMap<i32, bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestAuthTokenRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub box_cert: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub app_cert: ::prost::alloc::vec::Vec<u8>,
    /// signature of $LAZYCAT_APPID.$LAZYCAT_BOX_DOMAIN
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestAuthTokenResponse {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deadline: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Permission {
    /// 剪贴板
    Clipboard = 0,
    /// 设备信息
    DeviceInfo = 1,
    /// 弹出对话框
    OpenDialog = 2,
    /// 使用第三方app打开文件
    OpenThirdPartyApp = 3,
    /// 发送应用到桌面快捷方式
    PinApp = 4,
    /// 网络信息
    NetworkInfo = 5,
    /// 相册
    PhotoLibrary = 6,
    /// 文件
    Document = 7,
    /// 用户配置
    UserConfig = 8,
}
impl Permission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Clipboard => "CLIPBOARD",
            Self::DeviceInfo => "DEVICE_INFO",
            Self::OpenDialog => "OPEN_DIALOG",
            Self::OpenThirdPartyApp => "OPEN_THIRD_PARTY_APP",
            Self::PinApp => "PIN_APP",
            Self::NetworkInfo => "NETWORK_INFO",
            Self::PhotoLibrary => "PHOTO_LIBRARY",
            Self::Document => "DOCUMENT",
            Self::UserConfig => "USER_CONFIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIPBOARD" => Some(Self::Clipboard),
            "DEVICE_INFO" => Some(Self::DeviceInfo),
            "OPEN_DIALOG" => Some(Self::OpenDialog),
            "OPEN_THIRD_PARTY_APP" => Some(Self::OpenThirdPartyApp),
            "PIN_APP" => Some(Self::PinApp),
            "NETWORK_INFO" => Some(Self::NetworkInfo),
            "PHOTO_LIBRARY" => Some(Self::PhotoLibrary),
            "DOCUMENT" => Some(Self::Document),
            "USER_CONFIG" => Some(Self::UserConfig),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod permission_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 权限管理
    #[derive(Debug, Clone)]
    pub struct PermissionManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PermissionManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PermissionManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PermissionManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PermissionManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 检测权限
        pub async fn get_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::PermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PermissionReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PermissionManager/GetPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PermissionManager",
                        "GetPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 申请权限（会弹出对话框让用户决定是否同意）
        pub async fn request_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::PermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PermissionReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PermissionManager/RequestPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PermissionManager",
                        "RequestPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列举权限
        pub async fn list_permissions(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListPermissionsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PermissionManager/ListPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PermissionManager",
                        "ListPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 申请Token
        pub async fn request_auth_token(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestAuthTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestAuthTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PermissionManager/RequestAuthToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PermissionManager",
                        "RequestAuthToken",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPhotoHashRequest {
    /// changed_after语义为: changed_after之后的新增文件都会加入返回的集合里,
    /// 与文件本身的modify time无关。
    #[prost(message, optional, tag = "1")]
    pub changed_after: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPhotoRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeAlbumRequest {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutPhotoRequest {
    #[prost(string, tag = "1")]
    pub album_id: ::prost::alloc::string::String,
    /// 图片路径, 支持dataurl
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutPhotoReply {
    /// 是否完成. 若已完成则photo_id字段生效
    #[prost(bool, tag = "1")]
    pub done: bool,
    /// 若无total_size表示无法获取文件大小，此时无法计算出准确进度
    #[prost(int64, optional, tag = "2")]
    pub total_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub fetched_size: ::core::option::Option<i64>,
    /// 新添加图片的id, 仅在completed=true后才有意义
    #[prost(string, optional, tag = "4")]
    pub photo_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePhotoReply {
    /// 删除失败的图片id
    #[prost(string, repeated, tag = "1")]
    pub failed_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePhotoRequest {
    #[prost(string, repeated, tag = "1")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhotoMetasRequest {
    /// 相册ID, 若为空，则表示返回所有相册中的图片
    #[prost(string, repeated, tag = "1")]
    pub album_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "2")]
    pub thumbnail_width: i32,
    #[prost(int32, tag = "3")]
    pub thumbnail_height: i32,
    #[prost(bool, tag = "4")]
    pub need_file_name: bool,
    #[prost(bool, tag = "5")]
    pub need_album_ids: bool,
    /// 不填写默认按照创建时间降序排序
    #[prost(enumeration = "PhotoMetasSortType", optional, tag = "6")]
    pub stype: ::core::option::Option<i32>,
    /// 查询第几页(不填写默认为第一页)
    #[prost(uint32, optional, tag = "7")]
    pub page_num: ::core::option::Option<u32>,
    /// （每页返回的数据条数，不填写将返回所有数据）
    #[prost(uint32, optional, tag = "8")]
    pub page_size: ::core::option::Option<u32>,
    /// 是否过滤视频 （默认false,照片和视频信息一起返回)
    #[prost(bool, optional, tag = "9")]
    pub is_filter_video: ::core::option::Option<bool>,
    /// 给定文件的修改时间过滤meta信息返回
    #[prost(message, optional, tag = "10")]
    pub filter_by_modified_date: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    /// 相册ID， 若为空，则表示返回所有相册中的图片
    #[prost(string, repeated, tag = "1")]
    pub album_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 是否过滤视频 （默认false,照片和视频信息一起返回)
    #[prost(bool, optional, tag = "2")]
    pub is_filter_video: ::core::option::Option<bool>,
    /// 排序方法
    #[prost(enumeration = "ListAssetsSortType", optional, tag = "3")]
    pub sort_by: ::core::option::Option<i32>,
    /// 给定指定日期后的资源，为空表示获取全部
    #[prost(message, optional, tag = "4")]
    pub start_date: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhotoMeta {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// 浏览器直接可以使用的url, 可能是device domain下的一个文件或是一个data url
    #[prost(string, tag = "2")]
    pub photo_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub thumbnail_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub width: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub height: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub album_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "7")]
    pub size: i64,
    #[prost(string, tag = "8")]
    pub mime: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "10")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "11")]
    pub creation_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(float, optional, tag = "12")]
    pub latitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "13")]
    pub longitude: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "14")]
    pub taken_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "15")]
    pub modified_date: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Album {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub image_count: i32,
    #[prost(int32, tag = "4")]
    pub video_count: i32,
    #[prost(string, tag = "5")]
    pub cover_image_url: ::prost::alloc::string::String,
    /// 封面文件(图）id
    #[prost(string, tag = "6")]
    pub cover_image_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListAlbumsRequest {
    #[prost(int32, optional, tag = "1")]
    pub thumbnail_width: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub thumbnail_height: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub thumbnail_choose_way: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAlbumsReply {
    #[prost(message, repeated, tag = "1")]
    pub albums: ::prost::alloc::vec::Vec<Album>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListAssetStatsRequest {
    /// 是否过滤视频 （默认false,照片和视频信息一起返回)
    #[prost(bool, tag = "1")]
    pub is_filter_video: bool,
    /// 排序方法
    #[prost(enumeration = "ListAssetsSortType", tag = "2")]
    pub sort_by: i32,
    #[prost(message, optional, tag = "3")]
    pub start_date: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetStatsReply {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, optional, tag = "3")]
    pub mime: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsByIdsRequest {
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "ListAssetsSortType", tag = "2")]
    pub sort_by: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAssetUrlPathReply {
    #[prost(string, tag = "1")]
    pub asset_url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
/// 查询照片信息的排序方式
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PhotoMetasSortType {
    /// 创建时间降序
    CreateDateDesc = 0,
    /// 拍照时间降序
    TakenDateDesc = 1,
    /// 创建时间升序
    CreateDateAsc = 2,
    /// 拍摄时间升序
    TakenDateAsc = 3,
    /// 创建时间,拍摄时间降序
    CreateTakenDesc = 4,
    /// 创建时间,拍摄时间升序
    CreateTakenAsc = 5,
    /// 拍摄时间，创建时间 降序
    TokenCreateDesc = 6,
    /// 拍摄时间，创建时间升序
    TokenCreateAsc = 7,
}
impl PhotoMetasSortType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CreateDateDesc => "CREATE_DATE_DESC",
            Self::TakenDateDesc => "TAKEN_DATE_DESC",
            Self::CreateDateAsc => "CREATE_DATE_ASC",
            Self::TakenDateAsc => "TAKEN_DATE_ASC",
            Self::CreateTakenDesc => "CREATE_TAKEN_DESC",
            Self::CreateTakenAsc => "CREATE_TAKEN_ASC",
            Self::TokenCreateDesc => "TOKEN_CREATE_DESC",
            Self::TokenCreateAsc => "TOKEN_CREATE_ASC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_DATE_DESC" => Some(Self::CreateDateDesc),
            "TAKEN_DATE_DESC" => Some(Self::TakenDateDesc),
            "CREATE_DATE_ASC" => Some(Self::CreateDateAsc),
            "TAKEN_DATE_ASC" => Some(Self::TakenDateAsc),
            "CREATE_TAKEN_DESC" => Some(Self::CreateTakenDesc),
            "CREATE_TAKEN_ASC" => Some(Self::CreateTakenAsc),
            "TOKEN_CREATE_DESC" => Some(Self::TokenCreateDesc),
            "TOKEN_CREATE_ASC" => Some(Self::TokenCreateAsc),
            _ => None,
        }
    }
}
/// 查询照片信息的排序方式
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ListAssetsSortType {
    /// 创建时间降序
    AssetsCreateDateDesc = 0,
    /// 创建时间升序
    AssetsCreateDateAsc = 1,
    /// 时间线降序
    AssetsTimelineDateDesc = 2,
    /// 时间线升序
    AssetsTimelineDateAsc = 3,
    /// 修改时间降序
    AssetsModifiedDateDesc = 4,
    /// 修改时间升序
    AssetsModifiedDateAsc = 5,
}
impl ListAssetsSortType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AssetsCreateDateDesc => "ASSETS_CREATE_DATE_DESC",
            Self::AssetsCreateDateAsc => "ASSETS_CREATE_DATE_ASC",
            Self::AssetsTimelineDateDesc => "ASSETS_TIMELINE_DATE_DESC",
            Self::AssetsTimelineDateAsc => "ASSETS_TIMELINE_DATE_ASC",
            Self::AssetsModifiedDateDesc => "ASSETS_MODIFIED_DATE_DESC",
            Self::AssetsModifiedDateAsc => "ASSETS_MODIFIED_DATE_ASC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSETS_CREATE_DATE_DESC" => Some(Self::AssetsCreateDateDesc),
            "ASSETS_CREATE_DATE_ASC" => Some(Self::AssetsCreateDateAsc),
            "ASSETS_TIMELINE_DATE_DESC" => Some(Self::AssetsTimelineDateDesc),
            "ASSETS_TIMELINE_DATE_ASC" => Some(Self::AssetsTimelineDateAsc),
            "ASSETS_MODIFIED_DATE_DESC" => Some(Self::AssetsModifiedDateDesc),
            "ASSETS_MODIFIED_DATE_ASC" => Some(Self::AssetsModifiedDateAsc),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod photo_library_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct PhotoLibraryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PhotoLibraryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PhotoLibraryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PhotoLibraryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PhotoLibraryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn make_album(
            &mut self,
            request: impl tonic::IntoRequest<super::MakeAlbumRequest>,
        ) -> std::result::Result<tonic::Response<super::Album>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/MakeAlbum",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "MakeAlbum",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列举所有的系统相册
        pub async fn list_albums(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAlbumsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAlbumsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/ListAlbums",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "ListAlbums",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 存储一张图片到某个相册中
        pub async fn put_photo(
            &mut self,
            request: impl tonic::IntoRequest<super::PutPhotoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PutPhotoReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/PutPhoto",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "PutPhoto",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn delete_photo(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePhotoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePhotoReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/DeletePhoto",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "DeletePhoto",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 枚举具体相册中的图片元信息
        #[deprecated]
        pub async fn list_photo_metas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPhotoMetasRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PhotoMeta>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/ListPhotoMetas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "ListPhotoMetas",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 枚举相册中的资源（视频 & 图片）列表
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PhotoMeta>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "ListAssets",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn query_photo(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPhotoRequest>,
        ) -> std::result::Result<tonic::Response<super::PhotoMeta>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/QueryPhoto",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "QueryPhoto",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 查询指定条件的的图片id信息
        pub async fn list_asset_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ListAssetStatsReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/ListAssetStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "ListAssetStats",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 查询指定条件的的图片
        pub async fn list_assets_by_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsByIdsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PhotoMeta>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/ListAssetsByIds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "ListAssetsByIds",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 查询媒体资产 Url 路径
        pub async fn query_asset_url_path(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAssetUrlPathReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.PhotoLibrary/QueryAssetUrlPath",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.PhotoLibrary",
                        "QueryAssetUrlPath",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendKeyboardEventRequest {
    #[prost(enumeration = "InputEvent", tag = "1")]
    pub code: i32,
    #[prost(enumeration = "EventState", tag = "2")]
    pub state: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MovePosition {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendTouchpadEventRequest {
    #[prost(enumeration = "TouchEvent", tag = "1")]
    pub event: i32,
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<MovePosition>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendTouchpadMoveRequest {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<MovePosition>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendMouseMoveByDirectionRequest {
    #[prost(int32, tag = "1")]
    pub pixel: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendMouseMoveRequest {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendMouseWheelRequest {
    #[prost(bool, tag = "1")]
    pub horizontal: bool,
    #[prost(float, tag = "2")]
    pub delta: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRemoteScreenRectRequest {
    #[prost(int32, tag = "1")]
    pub height: i32,
    #[prost(int32, tag = "2")]
    pub width: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteClipboardRequest {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadClipboardResponse {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSinkInputsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sink_inputs: ::prost::alloc::vec::Vec<list_sink_inputs_response::SinkInput>,
}
/// Nested message and enum types in `ListSinkInputsResponse`.
pub mod list_sink_inputs_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SinkInput {
        #[prost(int32, tag = "1")]
        pub index: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub sink: i32,
        #[prost(bool, tag = "4")]
        pub muted: bool,
        #[prost(float, tag = "5")]
        pub volume: f32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSinksRepsonse {
    #[prost(message, repeated, tag = "1")]
    pub sinks: ::prost::alloc::vec::Vec<list_sinks_repsonse::Sink>,
    #[prost(message, optional, tag = "2")]
    pub defualt_sink: ::core::option::Option<list_sinks_repsonse::Sink>,
}
/// Nested message and enum types in `ListSinksRepsonse`.
pub mod list_sinks_repsonse {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sink {
        #[prost(int32, tag = "1")]
        pub index: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub muted: bool,
        #[prost(float, tag = "5")]
        pub volume: f32,
        #[prost(int32, tag = "6")]
        pub card_index: i32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub available: bool,
    #[prost(int32, tag = "4")]
    pub priority: i32,
    #[prost(int32, tag = "5")]
    pub sinks: i32,
    #[prost(int32, tag = "6")]
    pub sources: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCardsResponse {
    #[prost(message, repeated, tag = "1")]
    pub cards: ::prost::alloc::vec::Vec<list_cards_response::Card>,
}
/// Nested message and enum types in `ListCardsResponse`.
pub mod list_cards_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Card {
        #[prost(int32, tag = "1")]
        pub index: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub device_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub active_profile: ::core::option::Option<super::CardProfile>,
        #[prost(message, repeated, tag = "5")]
        pub profiles: ::prost::alloc::vec::Vec<super::CardProfile>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetDefaultSinkRequest {
    #[prost(int32, tag = "1")]
    pub sink_index: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCardProfileRequest {
    #[prost(int32, tag = "1")]
    pub card_index: i32,
    #[prost(string, tag = "2")]
    pub profile_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SinkRequest {
    #[prost(string, optional, tag = "1")]
    pub sink_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMuteResponse {
    #[prost(bool, tag = "1")]
    pub muted: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSinkMuteRequest {
    #[prost(string, optional, tag = "1")]
    pub sink_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub mute: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSinkVolumeResponse {
    #[prost(float, tag = "1")]
    pub volume: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeVolumeRequest {
    #[prost(float, tag = "1")]
    pub value: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetVolumeRequest {
    #[prost(float, tag = "1")]
    pub volume: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrowserActionRequest {
    #[prost(enumeration = "browser_action_request::Action", tag = "1")]
    pub action: i32,
}
/// Nested message and enum types in `BrowserActionRequest`.
pub mod browser_action_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        CloseTab = 0,
        NewTab = 1,
        RefreshTab = 2,
        BackwardHistory = 3,
        ForwardHistory = 4,
        ShowNumberNavigator = 5,
        HiddenNumberNavigator = 6,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CloseTab => "CLOSE_TAB",
                Self::NewTab => "NEW_TAB",
                Self::RefreshTab => "REFRESH_TAB",
                Self::BackwardHistory => "BACKWARD_HISTORY",
                Self::ForwardHistory => "FORWARD_HISTORY",
                Self::ShowNumberNavigator => "SHOW_NUMBER_NAVIGATOR",
                Self::HiddenNumberNavigator => "HIDDEN_NUMBER_NAVIGATOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLOSE_TAB" => Some(Self::CloseTab),
                "NEW_TAB" => Some(Self::NewTab),
                "REFRESH_TAB" => Some(Self::RefreshTab),
                "BACKWARD_HISTORY" => Some(Self::BackwardHistory),
                "FORWARD_HISTORY" => Some(Self::ForwardHistory),
                "SHOW_NUMBER_NAVIGATOR" => Some(Self::ShowNumberNavigator),
                "HIDDEN_NUMBER_NAVIGATOR" => Some(Self::HiddenNumberNavigator),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleDevice {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub paired: bool,
    #[prost(bool, tag = "5")]
    pub connected: bool,
    #[prost(bool, tag = "6")]
    pub trusted: bool,
    #[prost(int32, tag = "7")]
    pub rssi: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleDeviceRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleScanDevicesResponse {
    #[prost(message, repeated, tag = "1")]
    pub devices: ::prost::alloc::vec::Vec<BleDevice>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BleScanStatusResponse {
    #[prost(bool, tag = "1")]
    pub scanning: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScreenLayer {
    #[prost(enumeration = "Layer", tag = "1")]
    pub layer: i32,
    /// 如果screenlayer为custom需要传递这个参数
    #[prost(string, optional, tag = "2")]
    pub custom_playload: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugTestReply {
    #[prost(message, optional, tag = "2")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub pulseaudio: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub top: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBrowserUrlResponse {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OcrActionClickRequest {
    #[prost(string, repeated, tag = "1")]
    pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OcrActionClickResponse {
    #[prost(bool, tag = "1")]
    pub successful: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsrRecordTimeRequest {
    #[prost(bool, tag = "1")]
    pub is_start: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UseNumberNavigatorRequest {
    #[prost(string, tag = "1")]
    pub number: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseNumberNavigatorResponse {
    #[prost(bool, tag = "1")]
    pub successful: bool,
}
/// /usr/include/linux/input-event-codes.h
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InputEvent {
    KeyHome = 0,
    KeyBack = 1,
    KeyF11 = 2,
    KeyMenu = 3,
    KeyUp = 4,
    KeyDown = 5,
    KeyLeft = 6,
    KeyRight = 7,
    KeyPageup = 8,
    KeyPagedown = 9,
    KeyEnter = 10,
    KeyBackspace = 11,
    KeyF9 = 12,
    KeyHomepage = 13,
    KeyEnd = 14,
    KeyPause = 15,
    KeyPlay = 16,
}
impl InputEvent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KeyHome => "KEY_HOME",
            Self::KeyBack => "KEY_BACK",
            Self::KeyF11 => "KEY_F11",
            Self::KeyMenu => "KEY_MENU",
            Self::KeyUp => "KEY_UP",
            Self::KeyDown => "KEY_DOWN",
            Self::KeyLeft => "KEY_LEFT",
            Self::KeyRight => "KEY_RIGHT",
            Self::KeyPageup => "KEY_PAGEUP",
            Self::KeyPagedown => "KEY_PAGEDOWN",
            Self::KeyEnter => "KEY_ENTER",
            Self::KeyBackspace => "KEY_BACKSPACE",
            Self::KeyF9 => "KEY_F9",
            Self::KeyHomepage => "KEY_HOMEPAGE",
            Self::KeyEnd => "KEY_END",
            Self::KeyPause => "KEY_PAUSE",
            Self::KeyPlay => "KEY_PLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_HOME" => Some(Self::KeyHome),
            "KEY_BACK" => Some(Self::KeyBack),
            "KEY_F11" => Some(Self::KeyF11),
            "KEY_MENU" => Some(Self::KeyMenu),
            "KEY_UP" => Some(Self::KeyUp),
            "KEY_DOWN" => Some(Self::KeyDown),
            "KEY_LEFT" => Some(Self::KeyLeft),
            "KEY_RIGHT" => Some(Self::KeyRight),
            "KEY_PAGEUP" => Some(Self::KeyPageup),
            "KEY_PAGEDOWN" => Some(Self::KeyPagedown),
            "KEY_ENTER" => Some(Self::KeyEnter),
            "KEY_BACKSPACE" => Some(Self::KeyBackspace),
            "KEY_F9" => Some(Self::KeyF9),
            "KEY_HOMEPAGE" => Some(Self::KeyHomepage),
            "KEY_END" => Some(Self::KeyEnd),
            "KEY_PAUSE" => Some(Self::KeyPause),
            "KEY_PLAY" => Some(Self::KeyPlay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventState {
    Press = 0,
    Release = 1,
}
impl EventState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Press => "PRESS",
            Self::Release => "RELEASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRESS" => Some(Self::Press),
            "RELEASE" => Some(Self::Release),
            _ => None,
        }
    }
}
/// uinput TouchPad interface
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TouchEvent {
    MoveTo = 0,
    LeftClick = 1,
    RightClick = 2,
    LeftPress = 3,
    LeftRelease = 4,
    RightPress = 5,
    TouchDown = 6,
    TouchUp = 7,
}
impl TouchEvent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MoveTo => "MoveTo",
            Self::LeftClick => "LeftClick",
            Self::RightClick => "RightClick",
            Self::LeftPress => "LeftPress",
            Self::LeftRelease => "LeftRelease",
            Self::RightPress => "RightPress",
            Self::TouchDown => "TouchDown",
            Self::TouchUp => "TouchUp",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MoveTo" => Some(Self::MoveTo),
            "LeftClick" => Some(Self::LeftClick),
            "RightClick" => Some(Self::RightClick),
            "LeftPress" => Some(Self::LeftPress),
            "LeftRelease" => Some(Self::LeftRelease),
            "RightPress" => Some(Self::RightPress),
            "TouchDown" => Some(Self::TouchDown),
            "TouchUp" => Some(Self::TouchUp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Layer {
    /// 恢复默认
    Normal = 0,
    /// 黑色背景
    Black = 1,
    /// 自定义背景
    Custom = 2,
}
impl Layer {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "NORMAL",
            Self::Black => "BLACK",
            Self::Custom => "CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NORMAL" => Some(Self::Normal),
            "BLACK" => Some(Self::Black),
            "CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod remote_control_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct RemoteControlClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RemoteControlClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RemoteControlClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RemoteControlClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RemoteControlClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 发送键盘输入事件
        pub async fn send_keyboard_event(
            &mut self,
            request: impl tonic::IntoRequest<super::SendKeyboardEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendKeyboardEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendKeyboardEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发送触摸板输入事件
        /// 此接口发送的事件都是源事件，比如发送LeftPress，只会发起按下，不会发起松开
        /// 如果是想要单击等操作使用其他接口
        pub async fn send_touchpad_event(
            &mut self,
            request: impl tonic::IntoRequest<super::SendTouchpadEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendTouchpadEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendTouchpadEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发送左键
        pub async fn send_touchpad_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendTouchpadClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendTouchpadClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发送右键
        pub async fn send_touchpad_right_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendTouchpadRightClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendTouchpadRightClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发送双击
        pub async fn send_touchpad_double_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendTouchpadDoubleClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendTouchpadDoubleClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发送触摸板滑动
        pub async fn send_touchpad_move(
            &mut self,
            request: impl tonic::IntoRequest<super::SendTouchpadMoveRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendTouchpadMove",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendTouchpadMove",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标向左移动
        pub async fn send_mouse_move_left(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMouseMoveByDirectionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseMoveLeft",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseMoveLeft",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标向右移动
        pub async fn send_mouse_move_right(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMouseMoveByDirectionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseMoveRight",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseMoveRight",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标向上移动
        pub async fn send_mouse_move_up(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMouseMoveByDirectionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseMoveUp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseMoveUp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标向下移动
        pub async fn send_mouse_move(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMouseMoveRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseMove",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseMove",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 建立鼠标移动客户端流
        pub async fn mouse_move_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::SendMouseMoveRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/MouseMoveStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "MouseMoveStream",
                    ),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        /// 发起鼠标左键单击事件
        pub async fn send_mouse_left_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseLeftClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseLeftClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标右键单击事件
        pub async fn send_mouse_right_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseRightClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseRightClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标中键单击事件
        pub async fn send_mouse_middle_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseMiddleClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseMiddleClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 发起鼠标滚动
        pub async fn send_mouse_wheel(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMouseWheelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseWheel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseWheel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 建立流式鼠标滑动
        pub async fn mouse_wheel_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::SendMouseWheelRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/MouseWheelStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "MouseWheelStream",
                    ),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        /// 发起鼠标双击左键事件
        pub async fn send_mouse_double_click(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SendMouseDoubleClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SendMouseDoubleClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置远程屏幕的宽高(用于计算鼠标，触控板移动的同比例偏移)
        pub async fn set_remote_screen_rect(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRemoteScreenRectRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SetRemoteScreenRect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SetRemoteScreenRect",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 写入剪贴板
        pub async fn write_clipboard(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteClipboardRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/WriteClipboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "WriteClipboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 读取剪贴板
        pub async fn read_clipboard(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ReadClipboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ReadClipboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ReadClipboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 粘贴
        pub async fn do_paste(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/DoPaste",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "DoPaste",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 浏览器操作
        pub async fn browser_action(
            &mut self,
            request: impl tonic::IntoRequest<super::BrowserActionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BrowserAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BrowserAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 音频管理
        /// sink 输入音频设备 (可用于播放音频的音频设备)
        /// sink-input 输入音频流 (正在播放音频的程序)
        /// card 声卡，对应到某个物理设备
        /// card profile 声音可用的配置(立体声、环绕声)，影响sink和source
        /// 列出正在播放的输出音频流
        pub async fn list_sink_inputs(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListSinkInputsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ListSinkInputs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ListSinkInputs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出当前输入音频设备
        pub async fn list_sinks(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListSinksRepsonse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ListSinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ListSinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出当前可用的声卡
        pub async fn list_cards(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListCardsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ListCards",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ListCards",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置默认的输出音频设备
        pub async fn set_default_sink(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDefaultSinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SetDefaultSink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SetDefaultSink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置默认的输入音频设备
        pub async fn set_card_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::SetCardProfileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SetCardProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SetCardProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取是否被静音
        pub async fn get_mute(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetMuteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/GetMute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "GetMute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 切换静音状态
        pub async fn toggle_mute(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetMuteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ToggleMute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ToggleMute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取音量
        pub async fn get_volume(
            &mut self,
            request: impl tonic::IntoRequest<super::SinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSinkVolumeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/GetVolume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "GetVolume",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 增加音量
        pub async fn increase_volume(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/IncreaseVolume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "IncreaseVolume",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 减少音量
        pub async fn decrease_volume(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/DecreaseVolume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "DecreaseVolume",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置默认音频输入源音量
        pub async fn set_volume(
            &mut self,
            request: impl tonic::IntoRequest<super::SetVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SetVolume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SetVolume",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 蓝牙管理
        /// 停止扫描蓝牙设备
        pub async fn ble_stop_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleStopScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleStopScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 开始扫描蓝牙设备
        pub async fn ble_start_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleStartScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleStartScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 蓝牙设备扫描状态
        pub async fn ble_scan_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::BleScanStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleScanStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleScanStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 流式获取扫描蓝牙设备结果
        pub async fn ble_scan_devices(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BleScanDevicesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleScanDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleScanDevices",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 连接蓝牙设备
        pub async fn ble_connect_device(
            &mut self,
            request: impl tonic::IntoRequest<super::BleDeviceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleConnectDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleConnectDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 断开所有连接
        pub async fn ble_disconnect_device(
            &mut self,
            request: impl tonic::IntoRequest<super::BleDeviceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleDisconnectDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleDisconnectDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 删除蓝牙设备
        pub async fn ble_remove_device(
            &mut self,
            request: impl tonic::IntoRequest<super::BleDeviceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleRemoveDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleRemoveDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 刷新蓝牙设备列表
        pub async fn ble_refresh_devices(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/BleRefreshDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "BleRefreshDevices",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 切换ScreenLayer
        pub async fn set_screen_layer(
            &mut self,
            request: impl tonic::IntoRequest<super::ScreenLayer>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/SetScreenLayer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "SetScreenLayer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 返回当前的ScreenLayer
        pub async fn get_screen_layer(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ScreenLayer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/GetScreenLayer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "GetScreenLayer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 登出
        pub async fn logout(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/Logout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "Logout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 调试测试
        pub async fn debug_test(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DebugTestReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/DebugTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "DebugTest",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 获取浏览器当前url
        pub async fn get_browser_url(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetBrowserUrlResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/GetBrowserURL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "GetBrowserURL",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Ocr点击操作
        pub async fn ocr_action_click(
            &mut self,
            request: impl tonic::IntoRequest<super::OcrActionClickRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OcrActionClickResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/OcrActionClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "OcrActionClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Ocr进行扫描
        pub async fn ocr_do_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/OcrDoScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "OcrDoScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Asr耗时记录
        pub async fn asr_record_time(
            &mut self,
            request: impl tonic::IntoRequest<super::AsrRecordTimeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/AsrRecordTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "AsrRecordTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 重置显示画面
        pub async fn reset_display(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/ResetDisplay",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "ResetDisplay",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 选择某个数字导航点击
        pub async fn use_number_navigator(
            &mut self,
            request: impl tonic::IntoRequest<super::UseNumberNavigatorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UseNumberNavigatorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.RemoteControl/UseNumberNavigator",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.RemoteControl",
                        "UseNumberNavigator",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputContentReply {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsInputFocusResponse {
    #[prost(bool, tag = "1")]
    pub focus: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetInputTextRequest {
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod rim_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct RimClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RimClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RimClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RimClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RimClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 监听输入框聚焦
        pub async fn listen_input_focus(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InputContentReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/ListenInputFocus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.Rim",
                        "ListenInputFocus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 监听输入框失焦
        pub async fn listen_input_blur(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InputContentReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/ListenInputBlur",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.Rim",
                        "ListenInputBlur",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 获取当前聚焦输入框文本
        pub async fn get_input_text(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::InputContentReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/GetInputText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.localdevice.Rim", "GetInputText"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置当前聚焦输入框文本
        pub async fn set_input_text(
            &mut self,
            request: impl tonic::IntoRequest<super::SetInputTextRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/SetInputText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.localdevice.Rim", "SetInputText"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取当前是否有聚焦输入框
        pub async fn is_input_focus(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::IsInputFocusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/IsInputFocus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.localdevice.Rim", "IsInputFocus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 给聚焦窗口发送回车输入事件
        pub async fn send_input_event_enter(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.localdevice.Rim/SendInputEventEnter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.localdevice.Rim",
                        "SendInputEventEnter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
