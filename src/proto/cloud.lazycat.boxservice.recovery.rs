// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataDecryptResult {
    /// 如果失败，则代表密码错误。其它错误属于 bug，会抛出异常
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataChangePasswordResult {
    /// 如果失败，则代表密码错误。其它错误属于 bug，会抛出异常
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataListEncryptedResult {
    #[prost(string, repeated, tag = "1")]
    pub disks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataDiskFormat {
    /// 用于数据盘的磁盘（例如 /dev/vdb。如果留空，则自动扫描并使用所有的空盘）
    #[prost(string, repeated, tag = "1")]
    pub disks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 数据盘的密码（如果留空，则不加密）
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// 是否使用 bcache
    #[prost(bool, tag = "3")]
    pub bcache: bool,
    #[prost(enumeration = "data_disk_format::Profile", tag = "4")]
    pub data_profile: i32,
    #[prost(enumeration = "data_disk_format::Profile", tag = "5")]
    pub metadata_profile: i32,
}
/// Nested message and enum types in `DataDiskFormat`.
pub mod data_disk_format {
    /// 磁盘阵列 raid 相关
    /// btrfs 对此选项的标准全称叫作 "block group profile"
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Profile {
        /// 不主动设置，即使用 btrfs 默认，当前默认是 data=single, metadata=dup
        Unknown = 0,
        Raid0 = 1,
        Raid1 = 2,
        Single = 3,
        Dup = 4,
    }
    impl Profile {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::Raid0 => "Raid0",
                Self::Raid1 => "Raid1",
                Self::Single => "Single",
                Self::Dup => "Dup",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "Raid0" => Some(Self::Raid0),
                "Raid1" => Some(Self::Raid1),
                "Single" => Some(Self::Single),
                "Dup" => Some(Self::Dup),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataDiskDecrypt {
    /// 加密的密码，如果留空，则表示不加密
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataDiskChangePassword {
    /// 需要修改的磁盘（例如 /dev/vdb。如果留空，则自动扫描并使用所有的数据盘）
    #[prost(string, repeated, tag = "3")]
    pub disks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "1")]
    pub old_password: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxSystemStatus {
    #[prost(enumeration = "box_system_status::SysStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub service_url: ::prost::alloc::string::String,
    #[prost(enumeration = "box_system_status::ExceptionReason", optional, tag = "3")]
    pub exception_reason: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BoxSystemStatus`.
pub mod box_system_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SysStatus {
        /// 系统正在启动中
        Booting = 0,
        /// 处于正常可用状态
        Normal = 1,
        /// 处于异常状态，具体原因可读取ExceptionReason
        Exception = 2,
        /// 微服升级中，数秒后会自动重启，在该状态下，用户不应该使用盒子，以免导致数据丢失
        Upgrading2 = 3,
        /// 保留
        Reserved = 4,
    }
    impl SysStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Booting => "Booting",
                Self::Normal => "Normal",
                Self::Exception => "Exception",
                Self::Upgrading2 => "Upgrading2",
                Self::Reserved => "Reserved",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Booting" => Some(Self::Booting),
                "Normal" => Some(Self::Normal),
                "Exception" => Some(Self::Exception),
                "Upgrading2" => Some(Self::Upgrading2),
                "Reserved" => Some(Self::Reserved),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExceptionReason {
        /// 其他原因
        Unknown = 0,
        /// 等待加密数据盘被解密
        WaitDataDiskDecryption = 1,
        /// 数据盘没有初始化
        DataNotInit = 2,
        ///
        /// 1. 数据盘不存在（数据盘未插，或内部的 box.data.path 配置不正确）
        /// 2. 数据盘里已有分区（非 btrfs）
        /// 3. 数据盘无法挂载（文件系统损坏等）
        /// 4. 其它未意料的数据盘相关异常
        DataException = 3,
        /// 微服升级中，数秒后会自动重启，在该状态下，用户不应该使用盒子，以免导致数据丢失
        /// deprecated 请使用SysStatus的Upgrading2
        Upgrading = 4,
    }
    impl ExceptionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::WaitDataDiskDecryption => "WaitDataDiskDecryption",
                Self::DataNotInit => "DataNotInit",
                Self::DataException => "DataException",
                Self::Upgrading => "Upgrading",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "WaitDataDiskDecryption" => Some(Self::WaitDataDiskDecryption),
                "DataNotInit" => Some(Self::DataNotInit),
                "DataException" => Some(Self::DataException),
                "Upgrading" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod box_status_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BoxStatusServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BoxStatusServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BoxStatusServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BoxStatusServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BoxStatusServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 格式化（包含可选的设密码）
        pub async fn data_format(
            &mut self,
            request: impl tonic::IntoRequest<super::DataDiskFormat>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/DataFormat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "DataFormat",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 解密（无密码时不必调用）
        pub async fn data_decrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::DataDiskDecrypt>,
        ) -> std::result::Result<
            tonic::Response<super::DataDecryptResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/DataDecrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "DataDecrypt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 修改密码
        pub async fn data_change_password(
            &mut self,
            request: impl tonic::IntoRequest<super::DataDiskChangePassword>,
        ) -> std::result::Result<
            tonic::Response<super::DataChangePasswordResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/DataChangePassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "DataChangePassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获得加密的磁盘列表
        pub async fn data_list_encrypted(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DataListEncryptedResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/DataListEncrypted",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "DataListEncrypted",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// lzc-docker的数据可能因为断电、重启等原因损坏，且无法自动恢复。
        /// 遇到此问题只能删除全部的docker数据，提供此接口在出现问题时，由客服引导进入调试界面调用
        pub async fn clear_lzc_docker_data(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/ClearLZCDockerData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "ClearLZCDockerData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TODO: 在bridge.basic不再等待数据盘启动后可以迁移走此服务
        #[deprecated]
        pub async fn latest_sys_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BoxSystemStatus>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/LatestSysStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "LatestSysStatus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 不要调用!!!!!!!!!!!!! 请直接使用shell-api去获取相关状态
        #[deprecated]
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::BoxSystemStatus>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.BoxStatusService/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.BoxStatusService",
                        "GetStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfo {
    /// 热点的网卡 mac 地址（由于 ssid 可能重复，所以将此字段作为整个列表的 index）
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 热点的 ssid
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// 信号强度（范围 0 <= signal <= 100）
    #[prost(int32, tag = "3")]
    pub signal: i32,
    /// 是否需要密码
    #[prost(bool, tag = "4")]
    pub security: bool,
    /// 是否已连接
    #[prost(bool, tag = "5")]
    pub connected: bool,
    /// 是否已保存密码
    #[prost(bool, tag = "6")]
    pub saved: bool,
    /// 是否自动连接
    #[prost(bool, tag = "7")]
    pub auto_connected: bool,
    /// 是否锁定 bssid （锁定后，不会自动连接其他同名不同 bssid 的热点）
    #[prost(bool, tag = "8")]
    pub bssid_locked: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessPointInfoList {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<AccessPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStatusInfo {
    /// 是否已连接到互联网
    #[prost(bool, tag = "1")]
    pub has_internet: bool,
    /// 有线连接状态（已假设只有一块有线网卡）
    #[prost(enumeration = "NetworkDeviceStatus", tag = "2")]
    pub wired_device: i32,
    /// 无线设备状态（已假设只有一块无线网卡）
    #[prost(enumeration = "NetworkDeviceStatus", tag = "3")]
    pub wireless_device: i32,
    /// 若无线设备已连接，则该字段表示已连接的 wifi 的信息
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<AccessPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConnectInfo {
    /// bssid 和 ssid 指定其一即可
    #[prost(string, tag = "1")]
    pub bssid: ::prost::alloc::string::String,
    /// 当指定了 bssid 时，该值无效。所以要指定该值就不要指定 bssid
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// wifi 密码，如果 KeyMgmt 值是 KeyMgmtNone 则该值无效
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// 加密类型，该值一般不用指定，会自动嗅探，只有连接隐藏网络或手动添加网络才会用到此字段
    #[prost(enumeration = "KeyMgmt", optional, tag = "4")]
    pub key_mgmt: ::core::option::Option<i32>,
    /// 连接超时时间（单位：秒），如果不指定则为 NetworkManager 默认行为。
    /// 如果连接超时，会当作失败处理抛出异常
    #[prost(int64, optional, tag = "5")]
    pub timeout: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WifiConfigInfo {
    #[prost(string, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(enumeration = "KeyMgmt", tag = "3")]
    pub key_mgmt: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WifiConnectReply {
    #[prost(enumeration = "WifiConnectResult", tag = "1")]
    pub result: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkDeviceStatus {
    /// 不可用
    Unavailable = 0,
    /// 未连接
    Disconnected = 1,
    /// 正在连接
    Connecting = 2,
    /// 已连接
    Connected = 3,
    /// 正在断开
    Disconnecting = 4,
    /// 已禁用
    Disabled = 5,
}
impl NetworkDeviceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unavailable => "NetworkDeviceStatusUnavailable",
            Self::Disconnected => "NetworkDeviceStatusDisconnected",
            Self::Connecting => "NetworkDeviceStatusConnecting",
            Self::Connected => "NetworkDeviceStatusConnected",
            Self::Disconnecting => "NetworkDeviceStatusDisconnecting",
            Self::Disabled => "NetworkDeviceStatusDisabled",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NetworkDeviceStatusUnavailable" => Some(Self::Unavailable),
            "NetworkDeviceStatusDisconnected" => Some(Self::Disconnected),
            "NetworkDeviceStatusConnecting" => Some(Self::Connecting),
            "NetworkDeviceStatusConnected" => Some(Self::Connected),
            "NetworkDeviceStatusDisconnecting" => Some(Self::Disconnecting),
            "NetworkDeviceStatusDisabled" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyMgmt {
    None = 0,
    /// WEP  （最老的协议了，目前几乎没人用）
    Wep = 1,
    /// WPA/WPA2-Personal  （一般大概率都是这个，应当作为默认值）
    WpaPsk = 2,
    /// WPA3-Personal  （新一代协议，用的人比较少）
    Sae = 3,
}
impl KeyMgmt {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "KeyMgmtNone",
            Self::Wep => "KeyMgmtWEP",
            Self::WpaPsk => "KeyMgmtWPA_PSK",
            Self::Sae => "KeyMgmtSAE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KeyMgmtNone" => Some(Self::None),
            "KeyMgmtWEP" => Some(Self::Wep),
            "KeyMgmtWPA_PSK" => Some(Self::WpaPsk),
            "KeyMgmtSAE" => Some(Self::Sae),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WifiConnectResult {
    Success = 0,
    NoSuchBssid = 1,
    WrongPassword = 2,
    UnknownError = 3,
}
impl WifiConnectResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "WifiConnectResultSuccess",
            Self::NoSuchBssid => "WifiConnectResultNoSuchBssid",
            Self::WrongPassword => "WifiConnectResultWrongPassword",
            Self::UnknownError => "WifiConnectResultUnknownError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WifiConnectResultSuccess" => Some(Self::Success),
            "WifiConnectResultNoSuchBssid" => Some(Self::NoSuchBssid),
            "WifiConnectResultWrongPassword" => Some(Self::WrongPassword),
            "WifiConnectResultUnknownError" => Some(Self::UnknownError),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod network_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct NetworkManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NetworkManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NetworkManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NetworkManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 获取网络设备的状态（是否已连接，连接了哪个）
        pub async fn status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkDeviceStatusInfo>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.NetworkManager/Status",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.NetworkManager",
                        "Status",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Scan 扫描附近wifi热点信息，扫描结果在内部缓存里（阻塞，可能耗费数秒）
        pub async fn wifi_scan(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.NetworkManager/WifiScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.NetworkManager",
                        "WifiScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List 列出内部缓存中的 wifi 列表
        pub async fn wifi_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::AccessPointInfoList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.NetworkManager/WifiList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.NetworkManager",
                        "WifiList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 连接一个 wifi 热点
        ///   连接失败会删除已保存的配置，并自动连回上一次连接的 wifi（如果有的话），防止失联
        pub async fn wifi_connect(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConnectInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.NetworkManager/WifiConnect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.NetworkManager",
                        "WifiConnect",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 手动添加和连接一个 wifi 热点配置（用于连接隐藏网络）
        pub async fn wifi_config_add(
            &mut self,
            request: impl tonic::IntoRequest<super::WifiConfigInfo>,
        ) -> std::result::Result<
            tonic::Response<super::WifiConnectReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.boxservice.recovery.NetworkManager/WifiConfigAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.boxservice.recovery.NetworkManager",
                        "WifiConfigAdd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
