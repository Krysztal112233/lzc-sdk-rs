// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildApkRequest {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub app_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub app_icon: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildApkResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub apk_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub app_meta: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod apk_shell_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ApkShellClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApkShellClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApkShellClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApkShellClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApkShellClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 基于模板，根据传入的参数构建 APK
        /// 同一时间最多只能有一个构建任务在执行，并发的请求会阻塞
        /// 此方法不负责缓存生成的 APK，每次请求都会重新构建
        pub async fn build_apk(
            &mut self,
            request: impl tonic::IntoRequest<super::BuildApkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BuildApkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.ApkShell/BuildApk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.ApkShell", "BuildApk"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.ApkShell/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.ApkShell", "GetVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoxInfo {
    /// 硬件唯一ID,出厂后则不再变化
    #[prost(string, tag = "1")]
    pub udid: ::prost::alloc::string::String,
    /// 盒子的唯一名称，此名称是向中心化服务器注册产生，创建后不可修改
    #[prost(string, tag = "2")]
    pub box_name: ::prost::alloc::string::String,
    /// 盒子的唯一域名
    #[prost(string, tag = "3")]
    pub box_domain: ::prost::alloc::string::String,
    /// 盒子内部显示名称，可以随意修改，若不设置则为box_name
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// 电源灯是否亮
    #[prost(bool, tag = "7")]
    pub power_led: bool,
    #[prost(string, tag = "9")]
    pub cpu_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "10")]
    pub cpu_cores: i64,
    #[prost(int64, tag = "11")]
    pub cpu_threads: i64,
    #[prost(string, tag = "12")]
    pub memory_vendor: ::prost::alloc::string::String,
    #[prost(int64, tag = "13")]
    pub memory_total: i64,
    #[prost(int64, tag = "14")]
    pub memory_free: i64,
    #[prost(int64, tag = "15")]
    pub memory_speed: i64,
    #[prost(int64, tag = "16")]
    pub fan_rpm: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeDisplayNameRequest {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangePowerLedRequest {
    #[prost(bool, tag = "1")]
    pub power_led: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeTimeZoneRequest {
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTimeZoneResponse {
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {
    #[prost(enumeration = "shutdown_request::Action", tag = "1")]
    pub action: i32,
}
/// Nested message and enum types in `ShutdownRequest`.
pub mod shutdown_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// 关机
        Poweroff = 0,
        /// 重启
        Reboot = 1,
        /// 软重启（仅重启 lzc-os 容器，不关闭 lzc-base-os）
        ///     通常用于系统更新、故障修复等场景
        SoftReboot = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Poweroff => "Poweroff",
                Self::Reboot => "Reboot",
                Self::SoftReboot => "SoftReboot",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Poweroff" => Some(Self::Poweroff),
                "Reboot" => Some(Self::Reboot),
                "SoftReboot" => Some(Self::SoftReboot),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BootOption {
    #[prost(enumeration = "boot_option::BootOptionType", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `BootOption`.
pub mod boot_option {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BootOptionType {
        /// 无操作（清空所有已设置的操作）
        BootOptionNone = 0,
        /// 回滚到上一个版本
        BootOptionRollback = 1,
        /// 重置系统（清空系统的 var 数据）
        BootOptionReset = 2,
        /// 恢复出厂设置（清空用户信息、系统的 var 数据和用户数据）
        BootOptionFactoryReset = 3,
    }
    impl BootOptionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BootOptionNone => "BOOT_OPTION_NONE",
                Self::BootOptionRollback => "BOOT_OPTION_ROLLBACK",
                Self::BootOptionReset => "BOOT_OPTION_RESET",
                Self::BootOptionFactoryReset => "BOOT_OPTION_FACTORY_RESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BOOT_OPTION_NONE" => Some(Self::BootOptionNone),
                "BOOT_OPTION_ROLLBACK" => Some(Self::BootOptionRollback),
                "BOOT_OPTION_RESET" => Some(Self::BootOptionReset),
                "BOOT_OPTION_FACTORY_RESET" => Some(Self::BootOptionFactoryReset),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskInfo {
    /// 磁盘类型
    #[prost(enumeration = "disk_info::DiskType", tag = "1")]
    pub r#type: i32,
    #[prost(bool, tag = "11")]
    pub encrypted: bool,
    /// 盘位（仅当 type 为 Data 时才有效）
    #[prost(int32, tag = "2")]
    pub slot: i32,
    /// 型号
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    /// 序列号
    #[prost(string, tag = "4")]
    pub serial: ::prost::alloc::string::String,
    /// 磁盘容量（字节）（如果该值为 0，则表示该盘位未插盘）
    #[prost(int64, tag = "5")]
    pub size: i64,
    /// 剩余空间（字节）
    #[prost(int64, tag = "6")]
    pub free: i64,
    /// 温度
    #[prost(int32, tag = "7")]
    pub temperature: i32,
    /// 运行时间（小时）
    #[prost(int32, tag = "8")]
    pub power_on_hours: i32,
    #[prost(enumeration = "disk_info::Health", tag = "9")]
    pub health: i32,
    /// 健康状态理由
    #[prost(string, tag = "10")]
    pub health_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DiskInfo`.
pub mod disk_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskType {
        Unknown = 0,
        System = 1,
        Data = 2,
    }
    impl DiskType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::System => "System",
                Self::Data => "Data",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "System" => Some(Self::System),
                "Data" => Some(Self::Data),
                _ => None,
            }
        }
    }
    /// 健康状态
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Health {
        Normal = 0,
        Caution = 1,
        Bad = 2,
    }
    impl Health {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "Normal",
                Self::Caution => "Caution",
                Self::Bad => "Bad",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Normal" => Some(Self::Normal),
                "Caution" => Some(Self::Caution),
                "Bad" => Some(Self::Bad),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksInfo {
    #[prost(message, repeated, tag = "1")]
    pub disks: ::prost::alloc::vec::Vec<DiskInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeDataDisksPasswordRequest {
    #[prost(string, tag = "1")]
    pub old_password: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeDataDisksPasswordResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
}
/// Generated client implementations.
pub mod box_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BoxServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BoxServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BoxServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BoxServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BoxServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn query_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::BoxInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/QueryInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.BoxService", "QueryInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_display_name(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeDisplayNameRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/ChangeDisplayName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "ChangeDisplayName",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_power_led(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangePowerLedRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/ChangePowerLed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "ChangePowerLed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_time_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeTimeZoneRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/ChangeTimeZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "ChangeTimeZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_time_zone(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetTimeZoneResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/GetTimeZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "GetTimeZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_boot_option(
            &mut self,
            request: impl tonic::IntoRequest<super::BootOption>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/SetBootOption",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "SetBootOption",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/Shutdown",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.BoxService", "Shutdown"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_disks_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::DisksInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/QueryDisksInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "QueryDisksInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_data_disks_password(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeDataDisksPasswordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChangeDataDisksPasswordResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BoxService/ChangeDataDisksPassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BoxService",
                        "ChangeDataDisksPassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiServerInfo {
    #[prost(string, tag = "1")]
    pub frontend_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub backend_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionInfo {
    /// 当前登陆用户
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// 当前登陆设备
    #[prost(string, tag = "2")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub when: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppInfo {
    #[prost(string, tag = "1")]
    pub box_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub app_domain: ::prost::alloc::string::String,
    /// APIGateway对所有而http service服务强制要求设置http header类型的
    /// AuthInfo. 但有些场景无法使用XHR去设置自定义的http header，导致访问
    /// 这些服务很困难，因此由/usr/bin/lzcapp统一提供一个代理服务来设置这个
    /// header. 此字段即是对应代理出来的URL前缀。默认为"/_lzc"，可以通过启动
    /// 参数调整。
    #[prost(string, tag = "4")]
    pub http_api_proxy_path: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod browser_only_proxy_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// this service is provied by frontend server, backend code shouldn't use it.
    #[derive(Debug, Clone)]
    pub struct BrowserOnlyProxyClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BrowserOnlyProxyClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BrowserOnlyProxyClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BrowserOnlyProxyClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BrowserOnlyProxyClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 查询当前登陆用户对应信息
        pub async fn query_session_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::SessionInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BrowserOnlyProxy/QuerySessionInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BrowserOnlyProxy",
                        "QuerySessionInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 查询当前访问的lzcapp对应信息
        pub async fn query_app_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::AppInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BrowserOnlyProxy/QueryAppInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BrowserOnlyProxy",
                        "QueryAppInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 对devices.proto:_PairAllDeivces的自动封装
        pub async fn pair_all_devices(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<()>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BrowserOnlyProxy/PairAllDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BrowserOnlyProxy",
                        "PairAllDevices",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn query_api_server_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ApiServerInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.BrowserOnlyProxy/QueryAPIServerInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.BrowserOnlyProxy",
                        "QueryAPIServerInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// APIGateway在进行完权限检测放行后，转发给API Services时会通过metadata附带以下信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityContext {
    /// 请求来源的真实appid，一定是合法有效的
    ///
    /// key=X_LZCAPI_APPID
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    /// 请求来源的真实uid,一定是合法有效的
    ///
    /// key=X_LZCAPI_REALUID
    #[prost(string, tag = "2")]
    pub real_uid: ::prost::alloc::string::String,
    /// 请求来源期望的uid，注意此值可以被app server篡改
    /// 若uid != real_uid且对应SecurityContextRequire.disable_behalf_of_uid == true
    /// 则此请求会被APIGATEWAY阻止转发
    /// 若app server没有篡改此值，则此值与real_uid相同
    ///
    /// key=X_LZCAPI_UID
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
}
/// 以下权限要求通过option的方式声明在proto文件内
/// 并由APIGateway进行验证
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityContextRequire {
    #[prost(enumeration = "Permission", repeated, tag = "1")]
    pub require_permissions: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "UserClass", tag = "2")]
    pub require_user_class: i32,
    /// 请求必须直接通过app server发起，而非serverless端发起
    #[prost(bool, tag = "3")]
    pub require_from_backend: bool,
    /// 禁止app server伪造uid
    #[prost(bool, tag = "4")]
    pub disable_behalf_of_uid: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionDesc {
    /// 申请权限的原因说明
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    /// 权限列表
    #[prost(enumeration = "Permission", repeated, tag = "2")]
    pub permissions: ::prost::alloc::vec::Vec<i32>,
}
/// 后续调用lzc-apis时，需要带上此token
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionToken {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PermissionStatus {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HasPermissionRequest {
    #[prost(enumeration = "Permission", tag = "1")]
    pub perm: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Permission {
    /// 是否允许挂载用户文档数据
    UserDocument = 0,
    /// 是否允许安装软件
    InstallPackage = 1,
    /// 是否允许挂载可移动存储设备
    AccessRemoveableStoreage = 2,
    /// 是否允许生成访问EndDevice的访问凭证, EndDevice会进行具体API的权限验证
    AccessEnddevice = 1000,
    EnddeviceClipboard = 1001,
    EnddeviceNetworkInfo = 1002,
    EnddevicePhotolibrary = 1003,
}
impl Permission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UserDocument => "USER_DOCUMENT",
            Self::InstallPackage => "INSTALL_PACKAGE",
            Self::AccessRemoveableStoreage => "ACCESS_REMOVEABLE_STOREAGE",
            Self::AccessEnddevice => "ACCESS_ENDDEVICE",
            Self::EnddeviceClipboard => "ENDDEVICE_CLIPBOARD",
            Self::EnddeviceNetworkInfo => "ENDDEVICE_NETWORK_INFO",
            Self::EnddevicePhotolibrary => "ENDDEVICE_PHOTOLIBRARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_DOCUMENT" => Some(Self::UserDocument),
            "INSTALL_PACKAGE" => Some(Self::InstallPackage),
            "ACCESS_REMOVEABLE_STOREAGE" => Some(Self::AccessRemoveableStoreage),
            "ACCESS_ENDDEVICE" => Some(Self::AccessEnddevice),
            "ENDDEVICE_CLIPBOARD" => Some(Self::EnddeviceClipboard),
            "ENDDEVICE_NETWORK_INFO" => Some(Self::EnddeviceNetworkInfo),
            "ENDDEVICE_PHOTOLIBRARY" => Some(Self::EnddevicePhotolibrary),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserClass {
    /// 可以没有用户(比如一个纯后端app)或任何有效用户
    AnyUser = 0,
    /// 任何有效的用户
    NormalUser = 1,
    /// 必须是管理员用户
    AdminUser = 2,
    /// 请求者必须是资源所有者对应的用户，比如"设置密码"每个用户都有权设置，但仅能设置自身的
    /// 具体的TARGET_USER通过input message中的target_uid_field option进行标记
    TargetUser = 3,
}
impl UserClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AnyUser => "ANY_USER",
            Self::NormalUser => "NORMAL_USER",
            Self::AdminUser => "ADMIN_USER",
            Self::TargetUser => "TARGET_USER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANY_USER" => Some(Self::AnyUser),
            "NORMAL_USER" => Some(Self::NormalUser),
            "ADMIN_USER" => Some(Self::AdminUser),
            "TARGET_USER" => Some(Self::TargetUser),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SecurityContextMetaKey {
    MetaKeyXLzcapiAppid = 0,
    MetaKeyXLzcapiRealuid = 1,
    MetaKeyXLzcapiUid = 2,
}
impl SecurityContextMetaKey {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MetaKeyXLzcapiAppid => "META_KEY_X_LZCAPI_APPID",
            Self::MetaKeyXLzcapiRealuid => "META_KEY_X_LZCAPI_REALUID",
            Self::MetaKeyXLzcapiUid => "META_KEY_X_LZCAPI_UID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "META_KEY_X_LZCAPI_APPID" => Some(Self::MetaKeyXLzcapiAppid),
            "META_KEY_X_LZCAPI_REALUID" => Some(Self::MetaKeyXLzcapiRealuid),
            "META_KEY_X_LZCAPI_UID" => Some(Self::MetaKeyXLzcapiUid),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod permission_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct PermissionManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PermissionManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PermissionManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PermissionManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PermissionManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn request(
            &mut self,
            request: impl tonic::IntoRequest<super::PermissionDesc>,
        ) -> std::result::Result<
            tonic::Response<super::PermissionToken>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PermissionManager/Request",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PermissionManager",
                        "Request",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn has(
            &mut self,
            request: impl tonic::IntoRequest<super::HasPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PermissionStatus>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PermissionManager/Has",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.PermissionManager", "Has"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndDevice {
    /// TODO 待删除
    #[prost(string, tag = "1")]
    pub avoid_use_this_peer_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_online: bool,
    /// 因为device api的监听端口可能会变化，所以此url有效性不会太长
    #[prost(string, tag = "3")]
    pub device_api_url: ::prost::alloc::string::String,
    /// 由盒子维护的设备唯一ID，此ID是
    /// 根据客户端的多个特征推理出来的稳定ID
    /// 应用程序可以假设此ID是稳定不变的(实际依旧有可能变化)
    #[prost(string, tag = "4")]
    pub unique_deivce_id: ::prost::alloc::string::String,
    /// 设备型号，如果可以获取到
    #[prost(string, tag = "5")]
    pub model: ::prost::alloc::string::String,
    /// 设备名称，如果可以获取到
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// 设备绑定时间戳(即第一次成功登录的时间)
    #[prost(message, optional, tag = "7")]
    pub binding_time: ::core::option::Option<::prost_types::Timestamp>,
    /// 设备是否是移动平台
    #[prost(bool, tag = "8")]
    pub is_mobile: bool,
    /// 设备是否是电视平台
    #[prost(bool, tag = "9")]
    pub is_tv: bool,
    /// 本次登录的时间戳(如果is_online=true)
    #[prost(message, optional, tag = "10")]
    pub login_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndDeviceRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndDeviceReply {
    #[prost(message, repeated, tag = "1")]
    pub devices: ::prost::alloc::vec::Vec<EndDevice>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveEndDeviceRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub unique_deivce_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod end_device_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 懒猫云客户端设备管理服务
    #[derive(Debug, Clone)]
    pub struct EndDeviceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EndDeviceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EndDeviceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EndDeviceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EndDeviceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 枚举当前登陆用户所有的设备信息
        pub async fn list_end_devices(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEndDeviceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEndDeviceReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.EndDeviceService/ListEndDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.EndDeviceService",
                        "ListEndDevices",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 移除指定uid下面的指定设备(如果设备id为空，将会移除所有的设备）
        pub async fn remove_end_device(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveEndDeviceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.EndDeviceService/RemoveEndDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.EndDeviceService",
                        "RemoveEndDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileLocation {
    #[prost(enumeration = "file_location::FileLocationType", tag = "1")]
    pub location_type: i32,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FileLocation`.
pub mod file_location {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FileLocationType {
        Url = 0,
        Local = 2,
    }
    impl FileLocationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Url => "Url",
                Self::Local => "Local",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Url" => Some(Self::Url),
                "Local" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
/// TODO 考虑空文件夹
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaInfo {
    #[prost(string, tag = "1")]
    pub meta_info: ::prost::alloc::string::String,
}
/// Task创建请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskCreateRequest {
    /// src任意http url
    /// <https://7e-febf-6026-f14a-a3ec-0.d.heiyu.space:4443/s/files/home/abc.mp4>
    #[prost(message, optional, tag = "1")]
    pub src: ::core::option::Option<FileLocation>,
    /// app的files相对路径或具备PUT的webdav地址
    /// /home/abc.mp4 or
    /// <https://apis.snyht4.heiyu.space/s/files/home/video/abc.mp4>
    #[prost(message, optional, tag = "2")]
    pub dst: ::core::option::Option<FileLocation>,
    /// abc.mp4
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// 若queue 需提前创建，（固定前缀id）
    #[prost(message, optional, tag = "4")]
    pub queue_id: ::core::option::Option<TaskQueueId>,
    #[prost(enumeration = "TaskStatus", optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub meta_info: ::core::option::Option<MetaInfo>,
    /// 给相册后端用的, 用来告知transfer, 请求者的uid。这两个uid在用户下载被分享的相册的图片时有用。
    #[prost(string, optional, tag = "7")]
    pub uid: ::core::option::Option<::prost::alloc::string::String>,
    /// 给相册后端用的, 用来告知transfer, src(一定为本地路径，且为相对路径)的所属uid。
    #[prost(string, optional, tag = "8")]
    pub uid_src: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskCreateRequests {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<TaskCreateRequest>,
}
/// Task结构体
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransmitInfo {
    /// 总大小， 单位为 Byte
    #[prost(int64, tag = "1")]
    pub total: i64,
    /// 已传输大小， 单位为 Byte
    #[prost(int64, tag = "2")]
    pub transmitted: i64,
    /// 当前速度， 单位为 Byte/s
    #[prost(int64, tag = "3")]
    pub speed: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskId>,
    #[prost(message, optional, tag = "2")]
    pub src: ::core::option::Option<FileLocation>,
    #[prost(message, optional, tag = "3")]
    pub dst: ::core::option::Option<FileLocation>,
    #[prost(string, tag = "4")]
    pub file_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(enumeration = "TaskStatus", tag = "6")]
    pub status: i32,
    /// 前端请求可以没有大小，返回需要有
    #[prost(int64, optional, tag = "7")]
    pub size: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "8")]
    pub info: ::core::option::Option<TransmitInfo>,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub meta_info: ::core::option::Option<MetaInfo>,
}
///
/// 任务队列TaskQueue设计
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskQueueConfig {
    #[prost(int64, tag = "1")]
    pub max_parallel: i64,
    #[prost(int64, tag = "2")]
    pub max_rate_per_file: i64,
    #[prost(int64, tag = "3")]
    pub max_rate: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub uid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueConfigReq {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskQueueId>,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<TaskQueueConfig>,
}
/// TODO 考虑暂停状态问题
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueue {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskQueueId>,
    #[prost(enumeration = "QueueStatus", tag = "2")]
    pub status: i32,
    #[prost(message, repeated, tag = "3")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileTaskQueueResp {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskQueueId>,
    #[prost(enumeration = "QueueStatus", tag = "2")]
    pub status: i32,
    #[prost(message, repeated, tag = "3")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueQueryReq {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskQueueId>,
    #[prost(enumeration = "TaskStatus", repeated, tag = "2")]
    pub status: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "Order", optional, tag = "3")]
    pub order: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueStatisticsReq {
    #[prost(message, repeated, tag = "1")]
    pub id: ::prost::alloc::vec::Vec<TaskQueueId>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskQueueStatistics {
    /// 等待下载
    #[prost(int64, tag = "1")]
    pub pending: i64,
    /// 正在下载
    #[prost(int64, tag = "2")]
    pub transmitting: i64,
    /// 暂停
    #[prost(int64, tag = "3")]
    pub paused: i64,
    /// 已完成
    #[prost(int64, tag = "4")]
    pub finished: i64,
    /// 下载失败
    #[prost(int64, tag = "5")]
    pub failed: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueStatisticsResp {
    #[prost(message, repeated, tag = "1")]
    pub statistics: ::prost::alloc::vec::Vec<TaskQueueStatistics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueMessageResp {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskId>,
    #[prost(message, optional, tag = "2")]
    pub task: ::core::option::Option<Task>,
    #[prost(enumeration = "MsgAction", tag = "3")]
    pub action: i32,
    #[prost(enumeration = "TaskStatus", tag = "4")]
    pub status: i32,
    #[prost(string, optional, tag = "5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiniMessageResp {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskId>,
    #[prost(enumeration = "MsgAction", tag = "2")]
    pub action: i32,
    #[prost(enumeration = "TaskStatus", tag = "3")]
    pub status: i32,
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<TransmitInfo>,
    #[prost(message, optional, tag = "5")]
    pub task: ::core::option::Option<Task>,
    #[prost(string, optional, tag = "6")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskQueueListResp {
    #[prost(message, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<TaskQueueId>,
}
/// 上传文件夹的时候，src是http，dst是网盘中的相对路径。
/// 下载文件夹的时候，src是网盘中的相对路径，dst是http。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskFolderReq {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TaskQueueId>,
    #[prost(string, tag = "2")]
    pub src: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dst: ::prost::alloc::string::String,
}
/// Task 所有状态
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskStatus {
    /// 等待下载
    Pending = 0,
    /// 正在下载
    Transmitting = 1,
    /// 暂停
    Paused = 2,
    /// 已完成
    Finished = 3,
    /// 下载失败
    Failed = 4,
    /// 被移除状态，这个状态不会写入数据库，只有单个任务被删除的时候会出现
    Removed = 5,
    /// 表示前五种状态的合集，只在完成status参数为空(或者正好是前五个状态）时的 ClearQueue 时出现
    All = 6,
}
impl TaskStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Pending => "Pending",
            Self::Transmitting => "Transmitting",
            Self::Paused => "Paused",
            Self::Finished => "Finished",
            Self::Failed => "Failed",
            Self::Removed => "Removed",
            Self::All => "All",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Pending" => Some(Self::Pending),
            "Transmitting" => Some(Self::Transmitting),
            "Paused" => Some(Self::Paused),
            "Finished" => Some(Self::Finished),
            "Failed" => Some(Self::Failed),
            "Removed" => Some(Self::Removed),
            "All" => Some(Self::All),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueueStatus {
    /// 等待下载
    Running = 0,
    /// 已完成
    Suspend = 1,
}
impl QueueStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Running => "Running",
            Self::Suspend => "Suspend",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Running" => Some(Self::Running),
            "Suspend" => Some(Self::Suspend),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Order {
    Asc = 0,
    Desc = 1,
}
impl Order {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Asc => "ASC",
            Self::Desc => "DESC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASC" => Some(Self::Asc),
            "DESC" => Some(Self::Desc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MsgAction {
    Add = 0,
    Update = 2,
    Cancel = 3,
    UpdateAll = 4,
    CancelAll = 5,
    StartAll = 6,
    PauseAll = 7,
    NoAction = 100,
}
impl MsgAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "Add",
            Self::Update => "Update",
            Self::Cancel => "Cancel",
            Self::UpdateAll => "UpdateAll",
            Self::CancelAll => "CancelAll",
            Self::StartAll => "StartAll",
            Self::PauseAll => "PauseAll",
            Self::NoAction => "NoAction",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Add" => Some(Self::Add),
            "Update" => Some(Self::Update),
            "Cancel" => Some(Self::Cancel),
            "UpdateAll" => Some(Self::UpdateAll),
            "CancelAll" => Some(Self::CancelAll),
            "StartAll" => Some(Self::StartAll),
            "PauseAll" => Some(Self::PauseAll),
            "NoAction" => Some(Self::NoAction),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod file_transfer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FileTransferServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FileTransferServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FileTransferServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileTransferServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FileTransferServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 创建队列
        pub async fn create_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueId>,
        ) -> std::result::Result<
            tonic::Response<super::FileTaskQueueResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/CreateQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "CreateQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出所有 QueueID
        pub async fn list_queue(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::TaskQueueListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/ListQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "ListQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 通过队列的 ID 和 Status 获取任务列表
        pub async fn query_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueQueryReq>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Task>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/QueryQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "QueryQueue",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 通过队列的 ID 和 Status 获取任务状态，即running/paused等各个状态中各有多少个任务
        pub async fn query_queue_statistics(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueStatisticsReq>,
        ) -> std::result::Result<
            tonic::Response<super::TaskQueueStatisticsResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/QueryQueueStatistics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "QueryQueueStatistics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_queue_statistic(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueId>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TaskQueueStatistics>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/QueryQueueStatistic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "QueryQueueStatistic",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 通过队列的 ID 和 Status 清除任务
        pub async fn clear_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueQueryReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/ClearQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "ClearQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据队列 ID 设置队列的速率并发等设置
        pub async fn config_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueConfigReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/ConfigQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "ConfigQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据队列 ID 暂停队列
        pub async fn pause_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/PauseQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "PauseQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据队列 ID 开始队列
        pub async fn start_quque(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/StartQuque",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "StartQuque",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据队列 ID 获取队列动态信息（比如 pending 状态的增加了 task1）
        pub async fn query_queue_message(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueQueryReq>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::QueueMessageResp>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/QueryQueueMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "QueryQueueMessage",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 暂时不支持创建Task时创建任务，需要提前创建好任务。queue_id不存在则报错
        pub async fn create_task(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskCreateRequest>,
        ) -> std::result::Result<tonic::Response<super::Task>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/CreateTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "CreateTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskCreateRequests>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Task>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/CreateTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "CreateTasks",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 根据 ID 获取单个任务状态
        pub async fn query_task(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskId>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Task>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/QueryTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "QueryTask",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 根据 ID 开始单个任务
        pub async fn resume_task(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/ResumeTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "ResumeTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据 ID 暂停单个任务
        pub async fn pause_task(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/PauseTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "PauseTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据 ID 删除单个任务
        pub async fn delete_task(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/DeleteTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "DeleteTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn subscribe_queue_msg(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskQueueId>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MiniMessageResp>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/SubscribeQueueMsg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "SubscribeQueueMsg",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn create_task_upload_folder(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskFolderReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/CreateTaskUploadFolder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "CreateTaskUploadFolder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_task_download_folder(
            &mut self,
            request: impl tonic::IntoRequest<super::TaskFolderReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileTransferService/CreateTaskDownloadFolder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileTransferService",
                        "CreateTaskDownloadFolder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckExistsMessage {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirTreeRequest {
    /// 目录路径
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirTreeResponse {
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<dir_tree_response::FileInfo>,
}
/// Nested message and enum types in `DirTreeResponse`.
pub mod dir_tree_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FileInfo {
        /// 文件/目录路径
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
        /// 大小
        #[prost(int64, tag = "2")]
        pub size: i64,
        /// 最后修改时间
        #[prost(message, optional, tag = "3")]
        pub mtime: ::core::option::Option<::prost_types::Timestamp>,
        /// 是否为目录
        #[prost(bool, tag = "4")]
        pub is_dir: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TarDirRequest {
    /// 目录路径
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TarDirReply {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalkDirRequest {
    /// 目录路径
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// 过滤条件
    #[prost(string, optional, tag = "2")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// 遍历深度，只支持0或1。0表示无限制递归，1表示仅返回一层文件夹
    #[prost(int32, optional, tag = "4")]
    pub depth: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckWalkDirRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub diff_info: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "3")]
    pub depth: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckWalkDirResponse {
    #[prost(bool, tag = "1")]
    pub different: bool,
    /// 如果有不同，返回diffInfo信息
    #[prost(bytes = "vec", optional, tag = "2")]
    pub diff_info: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalkDirReply {
    /// 全路径 /home/lnks/hello.txt
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// 文件名 hello.txt
    #[prost(string, tag = "2")]
    pub base: ::prost::alloc::string::String,
    /// 文件大小
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// 是否为目录
    #[prost(bool, tag = "4")]
    pub is_dir: bool,
    /// 文件修改时间
    #[prost(message, optional, tag = "5")]
    pub mtime: ::core::option::Option<::prost_types::Timestamp>,
    /// 给予服务端保存，代表本次walkdir结果的hash数据
    /// 服务端拿着diffInfo调用CheckWalkDir，判断是否需要真正的walk
    #[prost(bytes = "vec", optional, tag = "6")]
    pub diff_info: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDirRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenFileManagerRequest {
    /// 文件(夹)绝对路径
    /// 1. window 下面的必须以盘符开头，如 C:\Users\lnks\Desktop
    /// 2. unix   下面的必须以 / 开头，如 /home/lnks/Desktop
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenRequest {
    /// 应用id
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    /// 文件路径
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(enumeration = "IntentAction", tag = "4")]
    pub intent_action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenReply {
    /// 打开应用的地址
    #[prost(string, optional, tag = "1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    /// 文件mime类型
    #[prost(string, tag = "1")]
    pub mime: ::prost::alloc::string::String,
    /// 文件路径(可选 android下面使用path查询，体验更好 ）
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    /// 期望的 app icon 尺寸(宽高一致）
    #[prost(int32, optional, tag = "3")]
    pub icon_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReply {
    #[prost(message, repeated, tag = "1")]
    pub app_list: ::prost::alloc::vec::Vec<AppShortcut>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppShortcut {
    #[prost(string, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    #[prost(enumeration = "IntentAction", tag = "4")]
    pub intent_action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// StatReply 和 golang fs.FileInfo 中字段保持一致
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatReply {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub size: i64,
    #[prost(uint32, tag = "3")]
    pub mode: u32,
    #[prost(message, optional, tag = "4")]
    pub mod_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "5")]
    pub is_dir: bool,
}
/// 同步文件夹请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFolderRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
    /// 服务器地址
    #[prost(string, tag = "2")]
    pub webdav_addr: ::prost::alloc::string::String,
    /// 服务器用户名
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// 服务器密码
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    /// 设备文件夹路径
    #[prost(string, tag = "5")]
    pub device_path: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub target_path: ::prost::alloc::string::String,
}
/// 复制文件夹请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyFolderRequest {
    #[prost(string, tag = "1")]
    pub box_name: ::prost::alloc::string::String,
    /// 服务器地址
    #[prost(string, tag = "2")]
    pub webdav_addr: ::prost::alloc::string::String,
    /// 服务器用户名
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// 服务器密码
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    /// 设备文件夹路径
    #[prost(string, tag = "5")]
    pub device_path: ::prost::alloc::string::String,
    /// 目标路径
    #[prost(string, tag = "6")]
    pub target_path: ::prost::alloc::string::String,
}
/// 文件进度信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProgress {
    /// 已经传输完成的文件体积
    #[prost(int64, tag = "1")]
    pub bytes: i64,
    /// 文件名称
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// 进度
    #[prost(int32, tag = "3")]
    pub percentage: i32,
    /// 文件体积
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// 文件传输速度
    #[prost(float, tag = "5")]
    pub speed: f32,
    /// 文件传输平均速度
    #[prost(float, tag = "6")]
    pub speed_avg: f32,
}
///   整体的进度信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskProgressInfo {
    /// 当code = 1, 任务完成。其他为异常退出
    #[prost(int32, tag = "1")]
    pub code: i32,
    /// 错误信息。
    #[prost(string, tag = "2")]
    pub msg: ::prost::alloc::string::String,
    /// 已经传输完的文件体积
    #[prost(int64, tag = "3")]
    pub bytes: i64,
    /// 所有需要传输的文件体积;
    #[prost(int64, tag = "4")]
    pub total_bytes: i64,
    /// 已经传输完成的文件数量;
    #[prost(int64, tag = "5")]
    pub transfers: i64,
    /// 所有要传输的文件数量;
    #[prost(int64, tag = "6")]
    pub total_transfers: i64,
    /// 已经检查过的文件数量;
    #[prost(int64, tag = "7")]
    pub checks: i64,
    /// 所有要检查的文件数量;
    #[prost(int64, tag = "8")]
    pub total_checks: i64,
    ///   已经删除的目录数量
    #[prost(int64, tag = "9")]
    pub deleted_dirs: i64,
    /// 已经删除的文件数量
    #[prost(int64, tag = "10")]
    pub deletes: i64,
    /// 当前任务消耗的时间
    #[prost(float, tag = "11")]
    pub elapsed_time: f32,
    /// eta 预计该任务传输完成的时间
    #[prost(int32, tag = "12")]
    pub eta: i32,
    /// 重命名文件的数量
    #[prost(int32, tag = "13")]
    pub renames: i32,
    /// 传输速度
    #[prost(float, tag = "14")]
    pub speed: f32,
    #[prost(message, repeated, tag = "15")]
    pub transferring: ::prost::alloc::vec::Vec<FileProgress>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntentAction {
    /// 未知
    UnKnown = 0,
    /// 打开
    Open = 1,
    /// 分享
    Share = 2,
}
impl IntentAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnKnown => "UN_KNOWN",
            Self::Open => "OPEN",
            Self::Share => "SHARE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UN_KNOWN" => Some(Self::UnKnown),
            "OPEN" => Some(Self::Open),
            "SHARE" => Some(Self::Share),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod file_handler_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FileHandlerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FileHandlerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FileHandlerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileHandlerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FileHandlerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn query(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/query",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "query"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn open(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenRequest>,
        ) -> std::result::Result<tonic::Response<super::OpenReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/open",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "open"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn open_file_manager(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenFileManagerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/openFileManager",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "openFileManager",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出目录结构
        pub async fn walk_dir(
            &mut self,
            request: impl tonic::IntoRequest<super::WalkDirRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WalkDirReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/walkDir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "walkDir"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn check_walk_dir(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckWalkDirRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckWalkDirResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/checkWalkDir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "checkWalkDir",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn walk_dir_duplex(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WalkDirRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WalkDirReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/walkDirDuplex",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "walkDirDuplex",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        pub async fn dir_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::DirTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DirTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/dirTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "dirTree"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_dir(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::CreateDirRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/createDir",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "createDir"),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn stat(
            &mut self,
            request: impl tonic::IntoRequest<super::StatRequest>,
        ) -> std::result::Result<tonic::Response<super::StatReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/stat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "stat"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 同步文件夹, 让target_path的内容和device_path内容一致.  device_path = target_path
        ///  sync A→B 的話
        ///  B=A
        pub async fn sync_folder(
            &mut self,
            request: impl tonic::IntoRequest<super::SyncFolderRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TaskProgressInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/syncFolder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "syncFolder",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 备份文件夹, 让server_path的内容和设备上的某个文件夹保持一致.
        ///    copy A→B 的話
        ///      B=A+B 原有檔案
        pub async fn copy_folder(
            &mut self,
            request: impl tonic::IntoRequest<super::CopyFolderRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TaskProgressInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/copyFolder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "copyFolder",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 打包某个目录为Tar，流式地上传回来
        pub async fn tar_dir(
            &mut self,
            request: impl tonic::IntoRequest<super::TarDirRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TarDirReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/tarDir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.FileHandler", "tarDir"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 检查目录是否存在
        pub async fn check_exists(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckExistsMessage>,
        ) -> std::result::Result<
            tonic::Response<super::CheckExistsMessage>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.FileHandler/checkExists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.FileHandler",
                        "checkExists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GatewayInfo {
    /// 域名信息
    #[prost(string, tag = "1")]
    pub base_domain: ::prost::alloc::string::String,
    /// 服务端口
    #[prost(string, tag = "2")]
    pub port: ::prost::alloc::string::String,
    /// 是否使用TLS
    #[prost(bool, tag = "3")]
    pub is_tls: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceInfo {
    #[prost(enumeration = "ServiceType", tag = "1")]
    pub service_type: i32,
    /// 如果是盒子上的第三方服务，则会强制验证$service_name是否与调用者的$appid匹配
    /// 系统内置的服务以及device apis不会做此检查
    #[prost(string, tag = "2")]
    pub service_name: ::prost::alloc::string::String,
    #[prost(enumeration = "TransportType", tag = "3")]
    pub transport_type: i32,
    #[prost(string, tag = "4")]
    pub service_addr: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterReply {
    #[prost(bool, tag = "1")]
    pub is_ok: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// gateway会对appid以及uid进行合法性检测，并在将request传递到service后端前，
    /// 设置到对应的grpc metadata或http header中，具体的字段名称会通过app_id_key以及user_id_key返回
    #[prost(string, tag = "3")]
    pub appid_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub uid_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessHttpServiceRequest {
    #[prost(string, tag = "1")]
    pub service_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpAccessInfo {
    /// 对应服务的URL
    #[prost(string, tag = "1")]
    pub service_url: ::prost::alloc::string::String,
    /// 若token_headername不为空，
    /// 则必须设置名称为$token_headername的http header为$token_value
    #[prost(string, tag = "2")]
    pub auth_headername: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub auth_value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransportType {
    /// 通用性最强，但会占用额外的端口并走完整的TCP/IP栈
    Tcp = 0,
    /// 仅限服务与Gateway同一进程内调用，数据直接走内存。性能最好，主要是device api类型使用。第三方服务无法使用此类型，仅限内部使用
    /// 特殊接口调用。
    InProcess = 1,
    /// 走unix socket, 依旧是跨进程但不走TCP/IP协议栈。性能一般，不要求同一进程，但需要让gateway本身能访问到对应服务的socket文件
    UnixSocket = 2,
}
impl TransportType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Tcp => "TCP",
            Self::InProcess => "InProcess",
            Self::UnixSocket => "UnixSocket",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TCP" => Some(Self::Tcp),
            "InProcess" => Some(Self::InProcess),
            "UnixSocket" => Some(Self::UnixSocket),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServiceType {
    /// 服务以grpc native的形式曝露给gateway。调用者拨号时直接使用gateway的地址即可，gateway会自动代理对应service name到正确的
    /// 服务后端。
    Grpc = 0,
    /// 服务以http的形式曝露给gateway。 调用者以https的形式访问gateway的地址下的特定url path来访问对应服务后端。
    /// 服务会统一曝露到 `<https://api.$boxdomain/s/$service_name/`>
    Http = 1,
}
impl ServiceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Grpc => "GRPC",
            Self::Http => "HTTP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRPC" => Some(Self::Grpc),
            "HTTP" => Some(Self::Http),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod api_gateway_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ApiGatewayClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApiGatewayClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApiGatewayClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiGatewayClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApiGatewayClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn query_gateway_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::GatewayInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.APIGateway/QueryGatewayInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.APIGateway",
                        "QueryGatewayInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_service(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceInfo>,
        ) -> std::result::Result<tonic::Response<super::RegisterReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.APIGateway/RegisterService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.APIGateway",
                        "RegisterService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 访问http service前，需要申请auth信息以便Gateway可以识别来源对应的
        /// 真实appid。
        /// 返回值尽量交由浏览器前端设置xhr对应参数。如果确实无法做到(比如img src中)，则
        /// 可以通过https://$appdomain/$service_proxy/的形式由/usr/bin/lzcapp代为
        /// 转发。此前缀可以通过BrowserOnlyProxy.proto接口获取到。
        pub async fn access_http_service(
            &mut self,
            request: impl tonic::IntoRequest<super::AccessHttpServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::HttpAccessInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.APIGateway/AccessHTTPService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.APIGateway",
                        "AccessHTTPService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserMediaMetaRequest {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// 相对于用户 home 目录的相对路径
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserMediaMetaResponse {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(uint32, tag = "3")]
    pub height: u32,
    #[prost(int64, tag = "4")]
    pub datetime: i64,
    #[prost(map = "string, string", tag = "5")]
    pub exif_data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateFileThumbnailRequest {
    /// 输出的文件
    #[prost(string, tag = "1")]
    pub input_file: ::prost::alloc::string::String,
    /// 参考大小
    /// 指定的尺寸为生成的缩略图最短边的长度。若指定的尺寸大于原图的最短边，则不会被缩放。
    /// 支持传入一个数组，同时生成多个格式的缩略图(等比缩放)。
    #[prost(uint32, repeated, tag = "2")]
    pub reference_sizes: ::prost::alloc::vec::Vec<u32>,
}
/// Generated client implementations.
pub mod media_meta_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MediaMetaClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MediaMetaClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MediaMetaClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MediaMetaClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MediaMetaClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_user_media_meta(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserMediaMetaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserMediaMetaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MediaMeta/GetUserMediaMeta",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MediaMeta",
                        "GetUserMediaMeta",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_user_media_meta_batch(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::GetUserMediaMetaRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetUserMediaMetaResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MediaMeta/GetUserMediaMetaBatch",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MediaMeta",
                        "GetUserMediaMetaBatch",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod thumbnail_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ThumbnailClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ThumbnailClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ThumbnailClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ThumbnailClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ThumbnailClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn generate_file_thumbnail(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateFileThumbnailRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.Thumbnail/GenerateFileThumbnail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.Thumbnail",
                        "GenerateFileThumbnail",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Msg {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(enumeration = "MsgType", tag = "2")]
    pub message_type: i32,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub meta: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub create_time: i64,
    #[prost(int64, tag = "7")]
    pub read_time: i64,
    #[prost(string, tag = "8")]
    pub receiver: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub msgs: ::prost::alloc::vec::Vec<Msg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MessageActionRequest {
    #[prost(int32, tag = "1")]
    pub id: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarkAsReadResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelMessageResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewMessageResponse {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewMessageRequest {
    #[prost(string, tag = "1")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(enumeration = "MsgType", tag = "2")]
    pub message_type: i32,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub meta: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HandleNoTrustDeviceUserRequest {
    #[prost(int32, tag = "1")]
    pub id: i32,
    #[prost(enumeration = "handle_no_trust_device_user_request::Answer", tag = "2")]
    pub answer: i32,
}
/// Nested message and enum types in `HandleNoTrustDeviceUserRequest`.
pub mod handle_no_trust_device_user_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Answer {
        Accept = 0,
        Reject = 1,
    }
    impl Answer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Accept => "Accept",
                Self::Reject => "Reject",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Accept" => Some(Self::Accept),
                "Reject" => Some(Self::Reject),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MsgType {
    /// 普通消息
    Normal = 0,
    /// 用户安装应用权限被修改
    UserInstallPermission = 1,
    /// 用户可见权限被修改
    UserAllowPermission = 2,
    /// 安装了新应用
    InstallNewApp = 3,
    /// 新用户加入盒子
    NewUser = 4,
    /// 盒子升级
    BoxUpgrade = 5,
    /// 应用升级
    AppUpgrade = 6,
    /// 用户没有受信任设备
    UserNoTrustdevice = 7,
}
impl MsgType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "NORMAL",
            Self::UserInstallPermission => "USER_INSTALL_PERMISSION",
            Self::UserAllowPermission => "USER_ALLOW_PERMISSION",
            Self::InstallNewApp => "INSTALL_NEW_APP",
            Self::NewUser => "NEW_USER",
            Self::BoxUpgrade => "BOX_UPGRADE",
            Self::AppUpgrade => "APP_UPGRADE",
            Self::UserNoTrustdevice => "USER_NO_TRUSTDEVICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NORMAL" => Some(Self::Normal),
            "USER_INSTALL_PERMISSION" => Some(Self::UserInstallPermission),
            "USER_ALLOW_PERMISSION" => Some(Self::UserAllowPermission),
            "INSTALL_NEW_APP" => Some(Self::InstallNewApp),
            "NEW_USER" => Some(Self::NewUser),
            "BOX_UPGRADE" => Some(Self::BoxUpgrade),
            "APP_UPGRADE" => Some(Self::AppUpgrade),
            "USER_NO_TRUSTDEVICE" => Some(Self::UserNoTrustdevice),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod message_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MessageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MessageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MessageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MessageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MessageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 列出所有消息
        pub async fn list_messages(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/ListMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "ListMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出所有已读消息
        pub async fn list_read_messages(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/ListReadMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "ListReadMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 列出所有未读消息
        pub async fn list_un_read_messages(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/ListUnReadMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "ListUnReadMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 根据消息ID查询某个消息，如果此前没有被Mark为已读，那么会变成已读
        pub async fn query_message(
            &mut self,
            request: impl tonic::IntoRequest<super::MessageActionRequest>,
        ) -> std::result::Result<tonic::Response<super::Msg>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/QueryMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "QueryMessage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 设置指定消息为已读
        pub async fn mark_as_read(
            &mut self,
            request: impl tonic::IntoRequest<super::MessageActionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MarkAsReadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/MarkAsRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "MarkAsRead",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 删除指定的消息
        pub async fn del_message(
            &mut self,
            request: impl tonic::IntoRequest<super::MessageActionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DelMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/DelMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "DelMessage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 新增一个消息
        pub async fn new_message(
            &mut self,
            request: impl tonic::IntoRequest<super::NewMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NewMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/NewMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "NewMessage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 流式的获取最新的消息
        pub async fn latest_message(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Msg>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/LatestMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "LatestMessage",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 处理普通用户没有受信任设备消息
        pub async fn handle_no_trust_device_user(
            &mut self,
            request: impl tonic::IntoRequest<super::HandleNoTrustDeviceUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.MessageService/HandleNoTrustDeviceUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.MessageService",
                        "HandleNoTrustDeviceUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountArchiveRequest {
    /// 要挂载的压缩文件的相对路径
    #[prost(string, tag = "1")]
    pub src_path: ::prost::alloc::string::String,
    /// 压缩文件要挂载到的目标路径
    #[prost(string, tag = "2")]
    pub mountpoint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesystemsReply {
    /// 当前APP未挂载的磁盘列表
    #[prost(message, repeated, tag = "1")]
    pub umounted: ::prost::alloc::vec::Vec<Filesystem>,
    /// 当前APP已挂载的磁盘列表。
    #[prost(message, repeated, tag = "2")]
    pub mounted: ::prost::alloc::vec::Vec<Filesystem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filesystem {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// ntfs/fat32/ext4 ...
    #[prost(string, tag = "2")]
    pub fstype: ::prost::alloc::string::String,
    /// partion label name or other meaningful name for user(eg. sda)
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// size unit in bytes
    #[prost(uint64, tag = "4")]
    pub size: u64,
    /// uuid of filesystem, maybe nil(eg. for fuse)
    #[prost(string, optional, tag = "5")]
    pub uuid: ::core::option::Option<::prost::alloc::string::String>,
    /// mountpoint of filesystem, nil if it's not mounted
    #[prost(string, optional, tag = "6")]
    pub mountpoint: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRemoteFilesystemReply {
    #[prost(message, repeated, tag = "1")]
    pub fs: ::prost::alloc::vec::Vec<RemoteFilesystem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteFilesystem {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(enumeration = "FsType", tag = "2")]
    pub fstype: i32,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub size: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub mountpoint: ::prost::alloc::string::String,
    /// remote connection healthy check
    #[prost(bool, tag = "7")]
    pub connected: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountDiskRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountRemoteDiskRequest {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(enumeration = "FsType", tag = "3")]
    pub fstype: i32,
    #[prost(string, tag = "4")]
    pub mountpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub port: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub options: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountRemoteDiskResp {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, repeated, tag = "2")]
    pub key: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub msg: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UmountFilesystemRequest {
    #[prost(oneof = "umount_filesystem_request::Target", tags = "1, 2")]
    pub target: ::core::option::Option<umount_filesystem_request::Target>,
}
/// Nested message and enum types in `UmountFilesystemRequest`.
pub mod umount_filesystem_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(string, tag = "1")]
        Uuid(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Mountpoint(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowerOffDiskRequest {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FsType {
    Samba = 0,
    Nfs = 1,
    Webdav = 2,
}
impl FsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Samba => "SAMBA",
            Self::Nfs => "NFS",
            Self::Webdav => "WEBDAV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SAMBA" => Some(Self::Samba),
            "NFS" => Some(Self::Nfs),
            "WEBDAV" => Some(Self::Webdav),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod peripheral_device_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 外围设备管理服务
    #[derive(Debug, Clone)]
    pub struct PeripheralDeviceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PeripheralDeviceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PeripheralDeviceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PeripheralDeviceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PeripheralDeviceServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 如果有设备变动，就返回一下 Empty，使用方需要 ListFilesystems 来获取具体信息
        pub async fn device_changed(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<()>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/DeviceChanged",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "DeviceChanged",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 列出当前盒子已挂载 和 可以挂载但未挂载的文件系统
        pub async fn list_filesystems(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListFilesystemsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/ListFilesystems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "ListFilesystems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 与物理磁盘的文件系统解耦, 仅提供远程挂载的文件系统
        pub async fn list_remote_filesystems(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListRemoteFilesystemReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/ListRemoteFilesystems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "ListRemoteFilesystems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 挂载/卸载特定移动磁盘的某个分区到
        /// $APPID/lzcapp/run/mnt/media/$partition_uuid 目录上
        pub async fn mount_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::MountDiskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/MountDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "MountDisk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 挂载 Smb/NFS/WebDAV 到 $APPID/lzcapp/run/mnt/home/$uid/.remotefs/$mountpoint 目录下
        pub async fn mount_remote_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::MountRemoteDiskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MountRemoteDiskResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/MountRemoteDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "MountRemoteDisk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 通过 uuid 或 mountpoint 卸载文件系统
        pub async fn umount_filesystem(
            &mut self,
            request: impl tonic::IntoRequest<super::UmountFilesystemRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/UmountFilesystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "UmountFilesystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn mount_archive(
            &mut self,
            request: impl tonic::IntoRequest<super::MountArchiveRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<()>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/MountArchive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "MountArchive",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 弹出外部存储设备
        pub async fn power_off_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::PowerOffDiskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.PeripheralDeviceService/PowerOffDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.PeripheralDeviceService",
                        "PowerOffDisk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserId {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckPasswordRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    #[prost(enumeration = "Role", tag = "4")]
    pub role: i32,
    #[prost(string, repeated, tag = "5")]
    pub phone_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "6")]
    pub has_app_install_permission: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListUiDsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUiDsReply {
    #[prost(string, repeated, tag = "1")]
    pub uids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeRoleReqeust {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(enumeration = "Role", tag = "2")]
    pub role: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetPasswordRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub old_password: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// 是否清理指定uid用户的数据目录
    #[prost(bool, tag = "2")]
    pub clear_user_data: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(enumeration = "Role", tag = "3")]
    pub role: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserInfoRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub phone_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceResetPasswordRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Role {
    Normal = 0,
    Admin = 1,
}
impl Role {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "ROLE_NORMAL",
            Self::Admin => "ROLE_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLE_NORMAL" => Some(Self::Normal),
            "ROLE_ADMIN" => Some(Self::Admin),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod user_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UserManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///  获取所有盒子用户的uid信息(允许任意有效用户)
        pub async fn list_ui_ds(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUiDsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListUiDsReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/ListUIDs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cloud.lazycat.apis.common.UserManager", "ListUIDs"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///  根据用户uid查询用户信息(允许任意有效用户)
        pub async fn query_user_info(
            &mut self,
            request: impl tonic::IntoRequest<super::UserId>,
        ) -> std::result::Result<tonic::Response<super::UserInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/QueryUserInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "QueryUserInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///  更新指定uid用户的nickname和avator(允许用户修改自己的用户信息)
        pub async fn update_user_info(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserInfoRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/UpdateUserInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "UpdateUserInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///  修改指定uid的用户角色(管理员角色允许调用)
        pub async fn change_role(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeRoleReqeust>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/ChangeRole",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "ChangeRole",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///  通过验证旧密码修改新的密码(允许用户重置自己的密码)
        pub async fn reset_password(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetPasswordRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/ResetPassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "ResetPassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 删除用户信息(管理员角色允许调用)
        pub async fn delete_user(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/DeleteUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "DeleteUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 创建用户信息(管理员角色允许调用)
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/CreateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "CreateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 强制重置用户密码（管理员角色允许调用)
        pub async fn force_reset_password(
            &mut self,
            request: impl tonic::IntoRequest<super::ForceResetPasswordRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/ForceResetPassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "ForceResetPassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 检测用户密码有效性（是否能够登录）
        pub async fn check_password(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckPasswordRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cloud.lazycat.apis.common.UserManager/CheckPassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cloud.lazycat.apis.common.UserManager",
                        "CheckPassword",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
